<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java IO——BIO、NIO和AIO学习]]></title>
    <url>%2F2018%2F05%2F28%2FJava-IO%E2%80%94%E2%80%94BIO%E3%80%81NIO%E5%92%8CAIO%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[无论是磁盘I/O还是网络I/O，数据在写入OutputStream或者从InputStream读取时都有可能会阻塞，而对数据的处理又存在同步和异步的效率问题。读了几篇文章之后，发现有几篇将的比较清楚，摘抄一下。 基本概念同步和异步 同步：如果有多个任务或者事件要发生，这些任务或者事件必须逐个地进行，一个事件或者任务的执行会导致整个流程的暂时等待，这些事件没有办法并发地执行 异步：如果有多个任务或者事件发生，这些事件可以并发地执行，一个事件或者任务的执行不会导致整个流程的暂时等待。 举个简单的例子，假如有一个任务包括两个子任务A和B，对于同步来说，当A在执行的过程中，B只有等待，直至A执行完毕，B才能执行，因此B任务依赖于A任务，这是一种可靠的任务序列；而对于异步就是A和B可以并发地执行，B不必等待A执行完毕之后再执行，这样就不会由于A的执行导致整个任务的暂时等待，即A任务是否最终完成B并不确定，这是不可靠的任务序列。异步不等于多线程，多线程只是实现异步的一种方式，因为也可以使用多进程实现异步。对于多线程的同步，比如：当多个线程同时访问一个变量时，每个线程访问该变量就是一个事件，对于同步来说，就是这些线程必须逐个地来访问该变量（可以通过synchronized关键字实现），一个线程在访问该变量的过程中，其他线程必须等待；而对于异步来说（即不做多线程的同步），就是多个线程不必逐个地访问该变量，可以同时进行访问。 阻塞和非阻塞 阻塞：当某个事件或者任务在执行过程中，它发出一个请求操作，但是由于该请求操作需要的条件不满足，那么就会一直在那等待，直至条件满足 非阻塞：当某个事件或者任务在执行过程中，它发出一个请求操作，如果该请求操作需要的条件不满足，会立即返回一个标志信息告知条件不满足，不会一直在那等待 阻塞与非阻塞主要是从CPU的消耗上来说的，阻塞就是CPU停下来等待一个慢的操作完成以后，CPU才接着完成其他事。非阻塞就是在这个慢的操作执行时CPU去干其他的事，等这个慢的操作完成时，CPU再接着完成后续的操作。非阻塞会造成系统的线程切换增加。 阻塞IO和非阻塞IOI/O操作过程：当用户线程发起一个IO请求操作（读请求操作为例），内核会去查看要读取的数据是否就绪，对于阻塞IO来说，如果数据没有就绪，则会一直在那等待，直到数据就绪；对于非阻塞IO来说，如果数据没有就绪，则会返回一个标志信息告知用户线程当前要读的数据没有就绪。当数据就绪之后，便将数据拷贝到用户线程，这样才完成了一个完整的IO读请求操作，也就是说一个完整的IO读请求操作包括两个阶段： 1）查看数据是否就绪； 2）进行数据拷贝（内核将数据拷贝到用户线程）。那么阻塞（blocking IO）和非阻塞（non-blocking IO）的区别就在于第一个阶段，如果数据没有就绪，在查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息。 同步IO和异步IO注意这里将的是IO操作。同步IO和异步IO模型是针对用户线程和内核的交互来说的：对于同步IO：当用户发出IO请求操作之后，如果数据没有就绪，需要通过用户线程或者内核不断地去轮询数据是否就绪，当数据就绪时，再将数据从内核拷贝到用户线程；而异步IO：只有IO请求操作的发出是由用户线程来进行的，IO操作的两个阶段都是由内核自动完成，然后发送通知告知用户线程IO操作已经完成。也就是说在异步IO中，不会对用户线程产生任何阻塞。 IO组合方式比较 组合方式 性能分析 同步阻塞 罪常用的一种用法，使用简单，但是I/O性能一般很差，CPU大部分处于空闲状态 同步非阻塞 提升I/O性能的常用手段，尤其在网络I/O是长连接同时传输数据也不是很多的情况下，提升性能非常有效。但是会增加CPU消耗，要考虑增加的I/O性能能不能补偿CPU的消耗，也就是系统的瓶颈是在I/O上还是在CPU上 异步阻塞 在分布式数据库中经常用到，对网络I/O能够提升效率，尤其是同时写多分相同数据的情况 异步非阻塞 比较复杂，只有在非常复杂的分布式情况下使用，集群之间的消息同步机制一般用这种方式，适合同时传多分相同的数据到集群中的不同机器，同时数据的传输量虽然不大但是非常频繁 五种I/O模型 阻塞IO模型：当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。 非阻塞IO模型：当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会返回一个标志信息。 多路复用IO模型：Java NIO实际上就是多路复用IO，在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。在Java NIO中，是通过selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。也许有朋友会说，我可以采用多线程+阻塞IO达到类似的效果，但是由于在多线程+阻塞IO中，每个socket对应一个线程，这样会造成很大的资源占用，并且尤其是对于长连接来说，线程的资源一直不会释放，如果后面陆续有很多连接的话，就会造成性能上的瓶颈。而多路复用IO模式，通过一个线程就可以管理多个socket，只有当socket真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用IO比较适合连接数比较多的情况。另外多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问socket状态是通过用户线程去进行的，而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。不过要注意的是，多路复用IO模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用IO模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。 信号驱动IO模型：在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。 异步IO模型：异步IO模型才是最理想的IO模型，在异步IO模型中，当用户线程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个asynchronous read之后，它会立刻返回，说明read请求已经成功发起了，因此不会对用户线程产生任何block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了。也就说用户线程完全不需要实际的整个IO操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了。 前面四种IO模型实际上都属于同步IO，只有最后一种是真正的异步IO，因为无论是多路复用IO还是信号驱动模型，IO操作的第2个阶段都会引起用户线程阻塞，也就是内核进行数据拷贝的过程都会让用户线程阻塞。 BIOBIO的服务端通信模型：采用BIO通信模型的服务端，通常由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理，处理完成后，通过输出流返回应答给客户端，线程销毁。即典型的请求一应答通信模型。模型图如下所示：缺点：缺乏弹性伸缩能力，当客户端并发访问量增加后，服务端的线程个数和客户端并发访问数呈1:1的正比关系，Java中的线程也是比较宝贵的系统资源，线程数量快速膨胀后，系统的性能将急剧下降，随着访问量的继续增大，系统最终就死-掉-了。模拟代码：首先提供一个读取消息的公共方法：123456789101112public class IOUtil &#123; public static String readMessage(BufferedReader in) throws IOException&#123; StringBuilder message = new StringBuilder(); while (true)&#123; if (!in.ready())&#123; break; &#125; message.append(in.readLine()).append(System.lineSeparator()); &#125; return message.toString(); &#125;&#125; 服务端代码：1234567891011121314151617181920212223242526272829303132333435363738public class Server &#123; private static int DEFAULT_PORT = 12345; private static ServerSocket server; //管理5个线程的线程池 private static ExecutorService executorService = Executors.newFixedThreadPool(5); public static void start() throws IOException &#123; start(DEFAULT_PORT); &#125; public synchronized static void start(int port) throws IOException &#123; if (server != null) &#123; return; &#125; try &#123; server = new ServerSocket(port); System.out.println(&quot;服务端已启动，端口号：&quot; + port); //监听客户端访问 while (true) &#123; //如果没有客户端接入，则阻塞在accept操作上 Socket socket = server.accept(); //方式一： 单线程处理客户端请求 //new ServerHandler(socket).run(); //方式二： 当监听到新的客户端连接请求时，新建线程处理请求，即每个连接对应一个线程，大量连接时影响服务器性能 //new Thread(new ServerHandler(socket)).start(); //方式三（伪异步I/O）：使用线程池中的线程处理该连接请求 executorService.execute(new ServerHandler(socket)); &#125; &#125; finally &#123; //关闭服务器socket if (server != null) &#123; System.out.println(&quot;关闭服务器&quot;); server.close(); server = null; &#125; &#125; &#125;&#125; 方式三使用了伪异步I/O，使用线程池管理线程，实现多个线程处理N个客户端的模型（但是底层还是使用的同步阻塞IO），其模型如下图所示：伪异步I/O弊端：因为限制了线程数量，如果发生大量并发请求，超过最大数量的线程就只能等待，直到线程池中的有空闲的线程可以被复用。因此在读取数据较慢时（比如数据量大、网络传输慢等），大量并发的情况下，其他接入的消息，只能一直等待，这就是最大的弊端。服务端消息处理线程：1234567891011121314151617181920212223242526272829303132333435public class ServerHandler implements Runnable &#123; private Socket socket; /** * 将socket连接作为参数传入处理线程 * * @param socket */ public ServerHandler(Socket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; try (BufferedReader in = new BufferedReader(new InputStreamReader(this.socket.getInputStream())); PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) &#123; String message = IOUtil.readMessage(in); System.out.println(&quot;服务器收到消息：&quot; + message); System.out.println(&quot;服务器处理消息：&quot; + message + &quot;，需耗时10s&quot;); Thread.sleep(10000); out.println(&quot;服务器返回消息：&quot; + message + &quot;计算完毕&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (socket != null) &#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; socket = null; &#125; &#125; &#125;&#125; 客户端代码：1234567891011121314151617181920212223242526272829public class Client &#123; //默认的端口号 private static int DEFAULT_SERVER_PORT = 12345; private static String DEFAULT_SERVER_IP = &quot;127.0.0.1&quot;; public static void send(String message) &#123; send(DEFAULT_SERVER_PORT, message); &#125; private static void send(int port, String message) &#123; System.out.println(&quot;客户端发送消息：&quot; + message); try (Socket socket = new Socket(DEFAULT_SERVER_IP, port); BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream())); PrintWriter out = new PrintWriter(socket.getOutputStream(), true) ) &#123; out.println(message); String receivedMessage; //如果服务端未返回消息，则一直保持连接并等待 while ((receivedMessage =IOUtil.readMessage(in)).equals(&quot;&quot;))&#123; &#125; System.out.println(&quot;客户端收到服务端消息：【&quot; + receivedMessage + &quot;】&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(&quot;客户端连接结束&quot;); &#125; &#125;&#125; 测试代码：1234567891011121314151617181920212223242526272829public class TestBIO &#123; public static void main(String[] args) throws Exception&#123; //启动服务端线程 new Thread(() -&gt; &#123; try &#123; Server.start(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;).start(); Thread.sleep(100); //启动客户端线程 char operators[] = &#123;&apos;+&apos;,&apos;-&apos;,&apos;*&apos;,&apos;/&apos;&#125;; Random random = new Random(System.currentTimeMillis()); //创建20个客户端连接请求 for(int i=0; i&lt;20; i++)&#123; new Thread(() -&gt; &#123; //随机产生算术表达式消息 String expression = random.nextInt(10)+&quot;&quot;+operators[random.nextInt(4)]+(random.nextInt(10)+1); Client.send(expression); try &#123; Thread.currentThread().sleep(random.nextInt(1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125; &#125;&#125; NIO缓冲区Buffer在NIO库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的；在写入数据时，也是写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。具体的缓存区有这些：ByteBuffe、CharBuffer、 ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer。他们实现了相同的接口：Buffer。Buffer可以理解为一组基本数据类型的元素列表，它通过几个变量来保存这个数据的当前位置状态，如下表所示： 索引 说明 capacity 缓冲区数组的总长度 position 下一个要操作的数据元素的位置 limit 缓冲区数组中不可操作的下一个元素的位置，limit&lt;=capacity mark 用于记录当前position的前一个位置或者默认是0 通过ByteBuffer.allocate(11)方法创建一个11个byte的数组缓冲区，初始状态如图所示：当写入5个字节时位置变化如图所示：然后需要将缓冲区的5个字节数据写入Channel通信信道，通过调用byteBuffer.flip()方法，数组的状态发生如图所示变化：此时底层操作系统就可以从缓冲区中正确读取这5个字节的数据并发送出去了。在下次写数据之前再调用一下clear()方法，缓冲区的索引状态又回到初始位置。mark：当调用mark()时，它将记录当前position的上一次的位置，当调用reset()时，position将恢复mark记录下来的值。 通道Channel我们对数据的读取和写入要通过Channel，通道是双向的，可以用于读、写和同时读写操作。 多路复用器SelectorSelector提供选择已经就绪的任务的能力：Selector会不断轮询注册在其上的Channel，如果某个Channel上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续的I/O操作。 示例首先定义一个对有读写事件的channel的处理接口，分别由服务端和客户端去具体实现：123456789public interface InputHandlerInterface &#123; /** * 对有读写事件或连接请求的channel的处理方式，分为服务端和客户端的不同 * @param selectionKey：表示注册到selector上的channel * @param selector：调度器 * @throws Exception */ void handleInput(SelectionKey selectionKey, Selector selector) throws Exception;&#125; 对channel读写的工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697public class HandlerUtil &#123; /** * 在channel上发送消息 * @param channel * @param message * @throws IOException */ public static void doWrite(SocketChannel channel, String message) throws IOException &#123; //将消息编码为字节数组 byte[] bytes = message.getBytes(&quot;utf-8&quot;); //根据数组容量创建ByteBuffer ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length); //将字节数组复制到缓冲区 writeBuffer.put(bytes); //flip操作 writeBuffer.flip(); //发送缓冲区的字节数组 channel.write(writeBuffer); System.out.println(Thread.currentThread().getName() + &quot;完成消息的发送：&quot; + message); //****此处不含处理“写半包”的代码 &#125; /** * 服务端或者客户端使用selector不断轮询注册在其上的Channel， * 如果某个Channel上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来， * 然后通过SelectionKey可以获取就绪Channel的集合，进行后续的I/O操作 * @param selector * @param inputHandler */ public static void select(Selector selector, InputHandlerInterface inputHandler)&#123; try &#123; //selector每隔1s被唤醒一次 //selector.select(1000); //阻塞,只有当至少一个注册的事件发生的时候才会继续 selector.select(); Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); if (inputHandler instanceof ServerInputHandler)&#123; System.out.println(&quot;服务端监听到的事件个数为：&quot; + selectionKeys.size()); &#125; if (inputHandler instanceof ClientInputHandler)&#123; System.out.println(&quot;客户端监听到的事件个数为：&quot; + selectionKeys.size()); &#125; Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator(); SelectionKey selectionKey; while (iterator.hasNext()) &#123; selectionKey = iterator.next(); iterator.remove(); try &#123; //在channel上进行IO操作 inputHandler.handleInput(selectionKey, selector); &#125; catch (Exception e) &#123; if (selectionKey != null) &#123; selectionKey.cancel(); if (selectionKey.channel() != null) &#123; selectionKey.channel().close(); &#125; &#125; &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 从通道中读消息 * @param sc * @return */ public static String readMessage(SocketChannel sc) throws IOException&#123; //创建ByteBuffer，并开辟一个1024的缓冲区 ByteBuffer buffer = ByteBuffer.allocate(1024); List&lt;byte[]&gt; bytesList = new ArrayList&lt;&gt;(); int byteNum = 0; //读取到字节，对字节进行编码 while ((sc.read(buffer)) &gt; 0) &#123; //给操作系统标识如何从缓冲区读取数据 buffer.flip(); //根据缓冲区可读字节数创建字节数组 byte[] bytes = new byte[buffer.remaining()]; //将缓冲区可读字节数组复制到新建的数组中 buffer.get(bytes); bytesList.add(bytes); byteNum += bytes.length; buffer.clear(); &#125; //此处可优化 byte[] allBytes = new byte[byteNum]; int offset = 0; for(byte[] tempBytes : bytesList)&#123; System.arraycopy(tempBytes, 0, allBytes, offset, tempBytes.length); offset += tempBytes.length; &#125; String message = new String(allBytes, &quot;utf-8&quot;); return message; &#125;&#125; 服务端代码：12345678910111213141516public class Server &#123; private static int DEFAULT_PORT = 12345; private static ServerHandler serverHandler; public static void start()&#123; start(DEFAULT_PORT); &#125; public static synchronized void start(int port)&#123; if (serverHandler != null)&#123; serverHandler.stop(); &#125; serverHandler = new ServerHandler(port); new Thread(serverHandler, &quot;Server&quot;).start(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class ServerHandler implements Runnable &#123; private Selector selector; private ServerSocketChannel serverChannel; private volatile boolean started; /** * 构造函数：指定要监听的端口号 * * @param port */ public ServerHandler(int port) &#123; try &#123; //创建选择器 this.selector = Selector.open(); //打开监听通道 this.serverChannel = ServerSocketChannel.open(); //开启非阻塞模式 this.serverChannel.configureBlocking(false); //通道绑定端口号，backlog设置为1024 this.serverChannel.socket().bind(new InetSocketAddress(port), 1024); //将channel注册入selector并设置其为监听连接请求 this.serverChannel.register(this.selector, SelectionKey.OP_ACCEPT); //标记服务端开启 this.started = true; System.out.println(&quot;服务端开启，端口号：&quot; + port); &#125; catch (IOException e) &#123; e.printStackTrace(); System.exit(1); &#125; &#125; public void stop() &#123; this.started = false; &#125; @Override public void run() &#123; //服务端处理线程 while (this.started) &#123; //使用selector监听并处理多路连接请求 HandlerUtil.select(this.selector, new ServerInputHandler()); &#125; //selector关闭后会自动释放里面管理的资源 if (this.selector != null) &#123; try &#123; this.selector.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 服务端对channel的处理（包括连接请求和可读事件）：123456789101112131415161718192021222324252627282930313233public class ServerInputHandler implements InputHandlerInterface &#123; @Override public void handleInput(SelectionKey selectionKey, Selector selector) throws Exception &#123; if (selectionKey.isValid()) &#123; //处理新接入的请求消息，即建立连接请求 //如果新来一个连接请求，则创建一个SocketChannel用来读取数据，并将该channel注册到selector中 if (selectionKey.isAcceptable()) &#123; ServerSocketChannel ssc = (ServerSocketChannel) selectionKey.channel(); //通过ServerSocketChannel的accept创建SocketChannel实例 //完成该操作意味着完成TCP三次握手，TCP物理链路正式建立 SocketChannel sc = ssc.accept(); //设置为非阻塞 sc.configureBlocking(false); //连接之后添加一个读事件，用来监听是否有可读数据 System.out.println(&quot;服务端收到连接请求!&quot;); sc.register(selector, SelectionKey.OP_READ); &#125; //从已建立的连接channel（SocketChannel）中读消息 if (selectionKey.isReadable()) &#123; SocketChannel sc = (SocketChannel) selectionKey.channel(); String message = HandlerUtil.readMessage(sc); System.out.println(&quot;服务端收到消息：&quot; + message); System.out.println(&quot;服务器处理消息：&quot; + message + &quot;，需耗时10s&quot;); Thread.sleep(10000); //发送应答消息 HandlerUtil.doWrite(sc, &quot;服务器返回消息：&quot; + message + &quot;计算完毕&quot;); //关闭通道 selectionKey.cancel(); sc.close(); &#125; &#125; &#125;&#125; 客户端代码：123456789101112131415161718192021222324252627282930public class Client &#123; private String host = &quot;127.0.0.1&quot;; private int port = 12345; private ClientHandler clientHandler; public Client(String host, int port)&#123; this.host = host; this.port = port; &#125; public void start() &#123; start(this.host, this.port); &#125; public void start(String ip, int port) &#123; if (this.clientHandler != null) this.clientHandler.stop(); this.clientHandler = new ClientHandler(ip, port); new Thread(this.clientHandler).start(); &#125; //向服务器发送消息 public boolean sendMsg(String msg) throws Exception &#123; if (msg.equals(&quot;q&quot;)) &#123; return false; &#125; this.clientHandler.sendMsg(msg); return true; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class ClientHandler implements Runnable &#123; private String host; private int port; private Selector selector; private SocketChannel socketChannel; private volatile boolean started; public ClientHandler(String ip, int port) &#123; this.host = ip; this.port = port; try &#123; //创建选择器 this.selector = Selector.open(); //打开监听通道 this.socketChannel = SocketChannel.open(); //如果为 true，则此通道将被置于阻塞模式；如果为 false，则此通道将被置于非阻塞模式 this.socketChannel.configureBlocking(false); this.started = true; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public void stop() &#123; this.started = false; &#125; @Override public void run() &#123; try &#123; //连接服务器 doConnect(); &#125; catch (IOException e) &#123; e.printStackTrace(); System.exit(1); &#125; while (this.started) &#123; HandlerUtil.select(this.selector, new ClientInputHandler()); &#125; //selector关闭后会自动释放里面管理的资源 if (selector != null) &#123; try &#123; selector.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 创建与服务器的连接，如果已经连接，则将连接注册到client的selector中 * * @throws IOException */ private void doConnect() throws IOException &#123; boolean connectResult = this.socketChannel.connect(new InetSocketAddress(this.host, this.port)); if (!connectResult) &#123; this.socketChannel.register(this.selector, SelectionKey.OP_CONNECT); &#125; System.out.println(&quot;客户端&quot; + Thread.currentThread().getName() + &quot;连接服务器成功！&quot;); &#125; /** * 先将连接注册进client的selector中，然后发送消息 * * @param message * @throws IOException */ public void sendMsg(String message) throws IOException &#123; this.socketChannel.register(this.selector, SelectionKey.OP_READ); System.out.println(&quot;客户端&quot; + Thread.currentThread().getName() + &quot;发送消息：&quot; + message); HandlerUtil.doWrite(this.socketChannel, message); &#125;&#125; 客户端只处理可读事件：12345678910111213141516171819202122232425public class ClientInputHandler implements InputHandlerInterface &#123; @Override public void handleInput(SelectionKey selectionKey, Selector selector) throws Exception &#123; if (selectionKey.isValid()) &#123; SocketChannel sc = (SocketChannel) selectionKey.channel(); if (selectionKey.isConnectable()) &#123; boolean finishConnect = sc.finishConnect(); if (!finishConnect) &#123; System.exit(1); &#125; sc.configureBlocking(false); //设置为可以读取服务器的数据 sc.register(selector, SelectionKey.OP_READ); System.out.println(&quot;客户端&quot; + Thread.currentThread().getName() + &quot;完成连接！&quot;); &#125; //读消息 if (selectionKey.isReadable()) &#123; String message = HandlerUtil.readMessage(sc); System.out.println(&quot;客户端&quot; + Thread.currentThread().getName() + &quot;收到消息：&quot; + message); selectionKey.cancel(); sc.close(); &#125; &#125; &#125;&#125; NIO测试：1234567891011121314151617181920212223242526272829public class TestNIO &#123; public static void main(String[] args) throws Exception &#123; //运行服务器 Server.start(); //避免客户端先于服务器启动前执行代码 Thread.sleep(100); char operators[] = &#123;&apos;+&apos;, &apos;-&apos;, &apos;*&apos;, &apos;/&apos;&#125;; Random random = new Random(System.currentTimeMillis()); //创建20个客户端连接请求 for (int i = 0; i &lt; 10; i++) &#123; System.out.println(&quot;启动第&quot; + i + &quot;个客户端&quot;); new Thread(()-&gt;&#123; //随机产生算术表达式消息 String expression = random.nextInt(10) + &quot;&quot; + operators[random.nextInt(4)] + (random.nextInt(10) + 1); //运行客户端 Client client = new Client(&quot;127.0.0.1&quot;, 12345); client.start(); try &#123; //创建连接所需时间，否则发送消息之前可能连接还未建立 Thread.sleep(500); client.sendMsg(expression); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125; &#125;&#125; AIONIO是非阻塞的，但未解决效率问题，需要逐个通道进行消息的处理。NIO 2.0引入了新的异步通道的概念，并提供了异步文件通道和异步套接字通道的实现。异步的套接字通道时真正的异步非阻塞I/O，对应于UNIX网络编程中的事件驱动I/O（AIO）。他不需要过多的Selector对注册的通道进行轮询即可实现异步读写，从而简化了NIO的编程模型。服务端代码：1234567891011121314151617public class AsyncServer &#123; private static int DEFAULT_PORT = 12345; private static AsyncServerHandler serverHandler; public volatile static long clientCount = 0; public static void start() &#123; start(DEFAULT_PORT); &#125; public static synchronized void start(int port) &#123; if (serverHandler != null) &#123; return; &#125; serverHandler = new AsyncServerHandler(port); new Thread(serverHandler, &quot;AsyncServer&quot;).start(); &#125;&#125; public class AsyncServerHandler implements Runnable { public CountDownLatch latch; public AsynchronousServerSocketChannel channel; public AsyncServerHandler(int port) { try { //创建异步服务管道 this.channel = AsynchronousServerSocketChannel.open(); //绑定端口号 this.channel.bind(new InetSocketAddress(port)); System.out.println(“服务端已启动，端口号：” + port); } catch (IOException e) { e.printStackTrace(); } } @Override public void run() { //CountDownLatch初始化 //它的作用：在完成一组正在执行的操作之前，允许当前的线程一直阻塞 //此处，让线程在此阻塞，防止服务端执行完成后退出 //也可以使用while(true)+sleep //生成环境就不需要担心这个问题，因为服务端是不会退出的 this.latch = new CountDownLatch(1); this.channel.accept(this, new ServerAcceptHandler()); try { this.latch.await(); } catch (InterruptedException e) { e.printStackTrace(); } } }服务端接收连接请求的处理：1234567891011121314151617public class ServerAcceptHandler implements CompletionHandler&lt;AsynchronousSocketChannel, AsyncServerHandler&gt; &#123; @Override public void completed(AsynchronousSocketChannel result, AsyncServerHandler attachment) &#123; AsyncServer.clientCount++; System.out.println(&quot;连接的客户端数：&quot; + AsyncServer.clientCount); attachment.channel.accept(attachment, this); ByteBuffer buffer = ByteBuffer.allocate(1024); //异步读 第三个参数为接收消息回调的业务Handler result.read(buffer, buffer, new ServerReadHandler(result)); &#125; @Override public void failed(Throwable exc, AsyncServerHandler attachment) &#123; exc.printStackTrace(); attachment.latch.countDown(); &#125;&#125; 服务端读事件处理：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class ServerReadHandler implements CompletionHandler&lt;Integer, ByteBuffer&gt; &#123; //用于读取半包消息和发送应答 private AsynchronousSocketChannel channel; public ServerReadHandler(AsynchronousSocketChannel channel)&#123; this.channel = channel; &#125; /** * 读到消息后的处理 * @param result * @param attachment */ @Override public void completed(Integer result, ByteBuffer attachment) &#123; attachment.flip(); byte[] bytes = new byte[attachment.remaining()]; attachment.get(bytes); try &#123; String message = new String(bytes, &quot;utf-8&quot;); System.out.println(&quot;服务端收到消息: &quot; + message); System.out.println(&quot;服务端处理消息：&quot; + message + &quot;，耗时10s&quot;); Thread.sleep(10000); //向客户端发送消息 doWrite(&quot;服务端完成消息的处理：&quot; + message); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 发送消息 * @param message */ private void doWrite(String message)&#123; byte[] bytes = message.getBytes(); ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length); writeBuffer.put(bytes); writeBuffer.flip(); //异步写 this.channel.write(writeBuffer, writeBuffer, new ServerWriteHandler(this.channel)); &#125; @Override public void failed(Throwable exc, ByteBuffer attachment) &#123; try &#123; this.channel.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 服务端写消息处理：12345678910111213141516171819202122232425262728public class ServerWriteHandler implements CompletionHandler&lt;Integer, ByteBuffer&gt; &#123; //用于读取半包消息和发送应答 private AsynchronousSocketChannel channel; public ServerWriteHandler(AsynchronousSocketChannel channel)&#123; this.channel = channel; &#125; @Override public void completed(Integer result, ByteBuffer attachment) &#123; if (attachment.hasRemaining())&#123; this.channel.write(attachment, attachment, this); &#125;else&#123; //创建新的buffer ByteBuffer readBuffer = ByteBuffer.allocate(1024); //异步读 this.channel.read(readBuffer, readBuffer, new ServerReadHandler(channel)); &#125; &#125; @Override public void failed(Throwable exc, ByteBuffer attachment) &#123; try &#123; channel.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 客户端代码：123456789101112131415161718192021222324252627282930313233343536public class AsyncClient &#123; private String DEFAULT_HOST = &quot;127.0.0.1&quot;; private int DEFAULT_PORT = 12345; private AsyncClientHandler clientHandler; public AsyncClient(String host, int port) &#123; this.DEFAULT_HOST = host; this.DEFAULT_PORT = port; &#125; public void start() &#123; start(DEFAULT_HOST, DEFAULT_PORT); &#125; public synchronized void start(String ip, int port) &#123; if (this.clientHandler != null) return; this.clientHandler = new AsyncClientHandler(ip, port); new Thread(this.clientHandler).start(); &#125; /** * 向服务端发送消息 * * @param msg * @return * @throws Exception */ public boolean sendMsg(String msg) throws Exception &#123; if (msg.equals(&quot;q&quot;)) &#123; return false; &#125; this.clientHandler.sendMsg(msg); return true; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class AsyncClientHandler implements CompletionHandler&lt;Void, AsyncClientHandler&gt;, Runnable &#123; private AsynchronousSocketChannel clientChannel; private String host; private int port; private CountDownLatch latch; public AsyncClientHandler(String host, int port) &#123; this.host = host; this.port = port; try &#123; //创建异步的客户端通道 this.clientChannel = AsynchronousSocketChannel.open(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void run() &#123; //创建CountDownLatch等待 this.latch = new CountDownLatch(1); //发起异步连接操作，回调参数就是这个类本身，如果连接成功会回调completed方法 this.clientChannel.connect(new InetSocketAddress(host, port), this, this); try &#123; this.latch.await(); this.clientChannel.close(); &#125; catch (InterruptedException e1) &#123; e1.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 连接服务器成功 * @param result * @param attachment */ @Override public void completed(Void result, AsyncClientHandler attachment) &#123; System.out.println(&quot;客户端成功连接到服务器&quot;); &#125; @Override public void failed(Throwable exc, AsyncClientHandler attachment) &#123; System.err.println(&quot;客户端连接服务器失败&quot;); exc.printStackTrace(); try &#123; this.clientChannel.close(); this.latch.countDown(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 向服务器发送消息 * @param msg */ public void sendMsg(String msg)&#123; byte[] req = msg.getBytes(); ByteBuffer writeBuffer = ByteBuffer.allocate(req.length); writeBuffer.put(req); writeBuffer.flip(); //异步写 this.clientChannel.write(writeBuffer, writeBuffer,new ClientWriteHandler(this.clientChannel, this.latch)); &#125;&#125; 客户端读事件处理：123456789101112131415161718192021222324252627282930313233public class ClientReadHandler implements CompletionHandler&lt;Integer, ByteBuffer&gt; &#123; private AsynchronousSocketChannel clientChannel; private CountDownLatch latch; public ClientReadHandler(AsynchronousSocketChannel clientChannel, CountDownLatch latch) &#123; this.clientChannel = clientChannel; this.latch = latch; &#125; @Override public void completed(Integer result, ByteBuffer attachment) &#123; attachment.flip(); byte[] bytes = new byte[attachment.remaining()]; attachment.get(bytes); String message; try &#123; message = new String(bytes, &quot;UTF-8&quot;); System.out.println(&quot;客户端收到消息:&quot; + message); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void failed(Throwable exc, ByteBuffer attachment) &#123; System.err.println(&quot;客户端读取数据失败&quot;); try &#123; this.clientChannel.close(); this.latch.countDown(); &#125; catch (IOException e) &#123; &#125; &#125;&#125; 客户端写消息处理：1234567891011121314151617181920212223242526272829303132public class ClientWriteHandler implements CompletionHandler&lt;Integer, ByteBuffer&gt; &#123; private AsynchronousSocketChannel clientChannel; private CountDownLatch latch; public ClientWriteHandler(AsynchronousSocketChannel clientChannel, CountDownLatch latch) &#123; this.clientChannel = clientChannel; this.latch = latch; &#125; @Override public void completed(Integer result, ByteBuffer attachment) &#123; //完成全部数据的写入 if (attachment.hasRemaining()) &#123; this.clientChannel.write(attachment, attachment, this); &#125; else &#123; //读取数据 ByteBuffer readBuffer = ByteBuffer.allocate(1024); this.clientChannel.read(readBuffer, readBuffer, new ClientReadHandler(this.clientChannel, this.latch)); &#125; &#125; @Override public void failed(Throwable exc, ByteBuffer attachment) &#123; System.err.println(&quot;客户端发送数据失败&quot;); try &#123; this.clientChannel.close(); this.latch.countDown(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; AIO测试1234567891011121314151617181920212223242526272829public class TestAIO &#123; public static void main(String[] args) throws Exception &#123; //运行服务器 AsyncServer.start(); //避免客户端先于服务器启动前执行代码 Thread.sleep(100); char operators[] = &#123;&apos;+&apos;, &apos;-&apos;, &apos;*&apos;, &apos;/&apos;&#125;; Random random = new Random(System.currentTimeMillis()); //创建20个客户端连接请求 for (int i = 0; i &lt; 10; i++) &#123; System.out.println(&quot;启动第&quot; + i + &quot;个客户端&quot;); new Thread(()-&gt;&#123; //随机产生算术表达式消息 String expression = random.nextInt(10) + &quot;&quot; + operators[random.nextInt(4)] + (random.nextInt(10) + 1); //运行客户端 AsyncClient client = new AsyncClient(&quot;127.0.0.1&quot;, 12345); client.start(); try &#123; //创建连接所需时间，否则发送消息之前可能连接还未建立 Thread.sleep(500); client.sendMsg(expression); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125; &#125;&#125; 可以看到aio异步处理消息，效率非常高。 nio处理文件通过io操作，实现大文件的复制传统方式：1234567891011121314public class FileIOUtil &#123; public static void copyFile(String fromPath, String toPath) throws IOException &#123; try (FileInputStream fin = new FileInputStream(fromPath); BufferedInputStream bis = new BufferedInputStream(fin); FileOutputStream fos = new FileOutputStream(toPath); BufferedOutputStream bos = new BufferedOutputStream(fos)) &#123; int temp; while ((temp = bis.read()) != -1) &#123; bos.write(temp); //写数据 bos.flush(); //强制输出 &#125; &#125; &#125;&#125; nio方式：12345678910111213141516171819202122232425public class FileNIOUtil &#123; public static void copyFile(String fromPath, String toPath) throws IOException &#123; try (FileInputStream fin = new FileInputStream(fromPath); FileOutputStream fos = new FileOutputStream(toPath);) &#123; //获取输入输出通道 FileChannel inChannel = fin.getChannel(); FileChannel outChannel = fos.getChannel(); //创建1024字节的缓存区 ByteBuffer buffer = ByteBuffer.allocate(1024); while(true)&#123; //重设此缓冲区，使它可以接受读入的数据。Buffer对象中的limit=capacity; buffer.clear(); //从输入通道中将数据读入到缓冲区 int temp = inChannel.read(buffer); if(temp == -1)&#123; break; &#125; //让缓冲区将新入读的输入写入另外一个通道.Buffer对象中的limit=position buffer.flip(); //从输出通道中将数据写入缓冲区 outChannel.write(buffer); &#125; &#125; &#125;&#125; 测试：1234567891011121314public class FileUtilTest &#123; public static void main(String[] args) throws IOException&#123; String fromPath = &quot;E:\\video\\白夜追凶\\白夜追凶\\32.mp4&quot;; String toPath = &quot;E:\\video\\白夜追凶\\32.mp4&quot;; long startTime = System.currentTimeMillis(); FileNIOUtil.copyFile(fromPath, toPath); long endTime = System.currentTimeMillis(); System.out.println(&quot;nio读写文件耗时：&quot; + (endTime-startTime) + &quot;毫秒&quot;); startTime = System.currentTimeMillis(); FileIOUtil.copyFile(fromPath, toPath); endTime = System.currentTimeMillis(); System.out.println(&quot;io读写文件耗时：&quot; + (endTime-startTime) + &quot;毫秒&quot;); &#125;&#125; 可以对比两种方式的速度，nio明显要快很多。 参考文章 Java NIO：浅析I/O模型 Java NIO：NIO概述 Java 网络IO编程总结（BIO、NIO、AIO均含完整实例代码） Java IO流和NIO流读写文件比较 深入分析Java Web技术内幕]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7搭建nexus maven私服]]></title>
    <url>%2F2018%2F05%2F02%2Fcentos7%E6%90%AD%E5%BB%BAnexus-maven%E7%A7%81%E6%9C%8D%2F</url>
    <content type="text"><![CDATA[自己的jar包需要发布到自己的私人maven仓库中以供自己在其他项目中引用。 安装nexus准备jdk1.8的环境 下载并解压nexus123wget http://download.sonatype.com/nexus/3/nexus-3.9.0-01-unix.tar.gztar -zxvf nexus-3.9.0-01-unix.tar.gz -C /optln -s /opt/nexus-3.9.0-01/ /opt/nexus #软连接 修改/opt/sonatype-work的权限1chmod 777 -R /opt/sonatype-work 创建nexus用户12adduser nexuschown -R nexus:nexus /opt/nexus 配置使用nexus用户运行nexus1vim /opt/nexus/bin/nexus.rc 配置run_as_user=&quot;nexus&quot; 将nexus配置为Linux服务12ln -s /opt/nexus/bin/nexus /etc/init.d/nexussystemctl enable nexus 启动nexus12systemctl start nexussystemctl status nexus 测试1curl http://localhost:8081 默认用户名为admin，默认密码为admin123 配置repositories因为国内阿里云的maven速度比较快，因此我们将自己的repository的代理指向阿里maven的仓库地址。如上图所示找到repositores的配置位置。默认有如下repository 修改maven-central的proxy地址 添加其他repository根据aliyun的仓库地址配置repository 参考文章 Installing Nexus OSS on Centos 7 centos7搭建nexus maven私服 Repository Manager 3]]></content>
      <categories>
        <category>CI</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>nexus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[try-catch-finally执行顺序]]></title>
    <url>%2F2018%2F04%2F12%2Ftry-catch-finally%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[本文探究异常捕获时try-catch-finally中有return时代码的执行顺序。 结论 finally代码块中的代码一定会执行 try或者catch中的return后面的表达式运算后，将待返回的值保存起来，该返回值不会随着finally块中的代码的执行而改变，然后执行finally代码块中的代码 不要在finally中return 验证123456789101112131415161718192021222324252627public void testFinallyWithException() &#123; try &#123; System.out.println(1 / 0); System.out.println(&quot;after exception&quot;); &#125; catch (ArithmeticException e) &#123; System.out.println(&quot;exception catch&quot;); throw e; &#125; finally &#123; System.out.println(&quot;finally&quot;); &#125; &#125; public void testTryInt()&#123; System.out.println(tryInt()); &#125; private int tryInt()&#123; int x = 1; try&#123; x++; //return x++; return ++x; &#125;finally &#123; x++; System.out.println(&quot;finally: &quot; + x); &#125; &#125; 参考文章 有return的情况下try catch finally的执行顺序]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot系列（七）——集成Elasticsearch]]></title>
    <url>%2F2018%2F04%2F04%2FSpringBoot%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E9%9B%86%E6%88%90Elasticsearch%2F</url>
    <content type="text"><![CDATA[本文介绍SpringBoot如何集成es以及es的基本操作。 创建客户端帮助类使用的es版本为v6.1.1 引入jar包12345678910&lt;dependency&gt; &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt; &lt;version&gt;6.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;transport&lt;/artifactId&gt; &lt;version&gt;6.1.1&lt;/version&gt;&lt;/dependency&gt; 创建工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125@Componentpublic class ESClientHelper &#123; private static Environment env; @Autowired public void setEnv(Environment env) &#123; ESClientHelper.env = env; &#125; private static boolean isInit = false; /** * 集群对应的客户端，key为clusterName */ private static Map&lt;String, Client&gt; clientMap = new ConcurrentHashMap&lt;&gt;(); /** * 初始化默认的client */ private static void init() &#123; System.setProperty(&quot;es.set.netty.runtime.available.processors&quot;, &quot;false&quot;); //集群1名称及es地址 String clusterName1 = ESClientHelper.env.getProperty(&quot;elasticsearch.cluster-name1&quot;); String cluster1nodes = ESClientHelper.env.getProperty(&quot;elasticsearch.cluster1-nodes&quot;); addClient(clusterName1, cluster1nodes); //集群2名称及es地址 String clusterName2 = ESClientHelper.env.getProperty(&quot;elasticsearch.cluster-name2&quot;); String cluster2nodes = ESClientHelper.env.getProperty(&quot;elasticsearch.cluster2-nodes&quot;); addClient(clusterName2, cluster2nodes); &#125; /** * 获得所有的地址端口 * * @return */ private static List&lt;TransportAddress&gt; getAllAddress(Map&lt;String, Integer&gt; ips) &#123; try &#123; List&lt;TransportAddress&gt; addressList = new ArrayList&lt;&gt;(); for (String ip : ips.keySet()) &#123; TransportAddress address = new TransportAddress(InetAddress.getByName(ip), ips.get(ip)); addressList.add(address); &#125; return addressList; &#125; catch (Exception ex) &#123; System.err.println(&quot;Initial ESClient creation failed.&quot; + ex); throw new ExceptionInInitializerError(ex); &#125; &#125; /** * 获取指定集群的es客户端 * * @param clusterName * @return */ public static Client getClient(String clusterName) &#123; if (!isInit) &#123; init(); isInit = true; &#125; return clientMap.get(clusterName); &#125; /** * 为其他集群添加客户端 * * @param setting 配置信息 * @param ips node-port列表，例如：127.0.0.1-9300 */ private static void addClient(Settings setting, Map&lt;String, Integer&gt; ips) &#123; List&lt;TransportAddress&gt; transportAddress = getAllAddress(ips); Client client = new PreBuiltTransportClient(setting) .addTransportAddresses(transportAddress.toArray(new TransportAddress[transportAddress.size()])); clientMap.put(setting.get(&quot;cluster.name&quot;), client); &#125; /** * 为其他集群添加客户端 * * @param clusterName 集群名 * @param strConnection 集群地址 */ public static void addClient(String clusterName, String strConnection) &#123; String[] nodeConnections = strConnection.split(&quot;;|,&quot;); Map&lt;String, Integer&gt; ips = new HashMap&lt;&gt;(); for (String nodeConnection : nodeConnections) &#123; Pattern pattern = Pattern.compile(&quot;(http://)*([.\\d]+):(\\d&#123;1,6&#125;)&quot;); Matcher matcher = pattern.matcher(nodeConnection); if (matcher.find()) &#123; try &#123; String hostname = matcher.group(2); int port = Integer.parseInt(matcher.group(3)); ips.put(hostname, port); &#125; catch (NumberFormatException e) &#123; e.printStackTrace(); &#125; &#125; &#125; Settings setting = Settings.builder() .put(&quot;cluster.name&quot;, clusterName) .put(&quot;client.transport.ignore_cluster_name&quot;, false) .put(&quot;client.transport.sniff&quot;, true).build(); addClient(setting, ips); &#125; /** * 判断索引是否存在 * * @param client * @param index * @return */ public static boolean indexExists(Client client, String index) &#123; IndicesExistsRequest request = new IndicesExistsRequest(index); IndicesExistsResponse response = client.admin().indices().exists(request).actionGet(); if (response.isExists()) &#123; return true; &#125; return false; &#125;&#125; 测试123456789101112@RunWith(SpringRunner.class)@SpringBootTestpublic class ESClientHelperTest &#123; @Autowired private Environment env; @Test public void testCreateIndex()&#123; Client client = ESClientHelper.getClient(env.getProperty(&quot;elasticsearch.cluster-name2&quot;)); System.out.println(ESClientHelper.indexExists(client, &quot;index&quot;)); &#125;&#125; 创建索引java中创建es索引需要首先生成type对应的source。es的java api没有提供像C#中NEST那样的特性（即注解），因此我们参照NEST首先写一个基于反射实现的工具类。 定义注解@ElasticProperty1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface ElasticProperty &#123; /** * 是否分词，默认不分词 * @return */ FieldIndexOption fieldIndex() default FieldIndexOption.NOTANALYZED; /** * 该字段分词时使用的分词器，默认使用ik_max_word * @return */ String analyzer() default &quot;ik_max_word&quot;; /** * 当字段为null时的默认值，默认为“-” * @return */ String nullValue() default &quot;-&quot;; /** * 日期格式 * @return */ String dateFormat() default &quot;yyyy-MM-dd HH:mm:ss&quot;; /** * fields * @return */ String fields() default &quot;&quot;; /** * 是否为nested字段 * @return */ NestOpinion isNested() default NestOpinion.NOTNESTED;&#125;public enum FieldIndexOption &#123; ANALYZED, NOTANALYZED&#125;public enum NestOpinion &#123; NESTED, NOTNESTED&#125; 使用@ElasticProperty定义type模型类Department:123456789101112131415161718192021222324252627282930313233343536373839public class Department &#123; private Long id; private String departmentName; @ElasticProperty(isNested = NestOpinion.NESTED) private List&lt;Employee&gt; employees; private List&lt;Business&gt; businessList; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getDepartmentName() &#123; return departmentName; &#125; public void setDepartmentName(String departmentName) &#123; this.departmentName = departmentName; &#125; public List&lt;Employee&gt; getEmployees() &#123; return employees; &#125; public void setEmployees(List&lt;Employee&gt; employees) &#123; this.employees = employees; &#125; public List&lt;Business&gt; getBusinessList() &#123; return businessList; &#125; public void setBusinessList(List&lt;Business&gt; businessList) &#123; this.businessList = businessList; &#125;&#125; 类Employee:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Employee &#123; private String name; private Integer age; @ElasticProperty(fieldIndex = FieldIndexOption.ANALYZED, fields = &quot;&#123;\&quot;raw\&quot;: &#123;\&quot;type\&quot;: \&quot;keyword\&quot;&#125;&#125;&quot;) private String profile; @ElasticProperty(dateFormat = &quot;yyyy-MM-dd&quot;) @JSONField(format=&quot;yyyy-MM-dd&quot;) private Date birth; private List&lt;String&gt; articles; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getProfile() &#123; return profile; &#125; public void setProfile(String profile) &#123; this.profile = profile; &#125; public Date getBirth() &#123; return birth; &#125; public void setBirth(Date birth) &#123; this.birth = birth; &#125; public List&lt;String&gt; getArticles() &#123; return articles; &#125; public void setArticles(List&lt;String&gt; articles) &#123; this.articles = articles; &#125;&#125; 类Business:1234567891011121314151617181920public class Business &#123; private String core; private Float revenue; public String getCore() &#123; return core; &#125; public void setCore(String core) &#123; this.core = core; &#125; public Float getRevenue() &#123; return revenue; &#125; public void setRevenue(Float revenue) &#123; this.revenue = revenue; &#125;&#125; 实现工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128public class ElasticsearchMappingGenerator &#123; private final static String mappingPattern = &quot;\&quot;$type\&quot;: &#123;\&quot;properties\&quot;: &#123;$properties&#125;&#125;&quot;; private final static String nestedMappingPattern = &quot;\&quot;$type\&quot;: &#123;\&quot;type\&quot;: \&quot;nested\&quot;, \&quot;properties\&quot;: &#123;$properties&#125;&#125;&quot;; private final static String propertyPattern = &quot;\&quot;$fieldName\&quot;: &#123;$parameters&#125;&quot;; private final static String parameterPattern = &quot;\&quot;$parameterName\&quot;: \&quot;$parameterValue\&quot;&quot;; private final static String fieldsPattern = &quot;\&quot;fields\&quot;: $fieldsValue&quot;; /** * 生成type对应的source * @param clazz：定义的类模型 * @param fieldName：为null时，则只有properties，即为source；不为null时，表示要生成模型中某个字段的source * @param isNested：fieldName不为null时有意义，true表示该字段为nested * @return */ public static String generateSource(Class&lt;?&gt; clazz, String fieldName, boolean isNested)&#123; String result; StringBuilder properties = new StringBuilder(); if (fieldName == null) &#123; //主resource只有properties result = mappingPattern.replace(&quot;\&quot;$type\&quot;: &quot;, &quot;&quot;); &#125;else&#123; //字段对应的resource if (isNested)&#123; //nested字段 result = nestedMappingPattern.replace(&quot;$type&quot;, fieldName); &#125;else&#123; result = mappingPattern.replace(&quot;$type&quot;, fieldName); &#125; &#125; Field[] fields = clazz.getDeclaredFields(); boolean isFirst = true; for (Field field : fields) &#123; if (isFirst) &#123; properties.append(generateProperty(field)); isFirst = false; &#125; else &#123; properties.append(&quot;, &quot;).append(generateProperty(field)); &#125; &#125; return result.replace(&quot;$properties&quot;, properties.toString()); &#125; /** * 获取字段的mapping * * @param field * @return */ private static String generateProperty(Field field) &#123; String fieldName = field.getName(); //获取字段类型 Class&lt;?&gt; fieldType = field.getType(); //获取@ElasticProperty注解 ElasticProperty elasticProperty = field.getAnnotation(ElasticProperty.class); String type; //field为列表类型 if (fieldType.equals(List.class)) &#123; //Array dataType Type genericType = field.getGenericType(); if (genericType instanceof ParameterizedType)&#123; fieldType = (Class)((ParameterizedType)genericType).getActualTypeArguments()[0]; &#125; &#125; //字段为String类型，需要判断是否分词 if (fieldType.equals(String.class)) &#123; if (elasticProperty != null &amp;&amp; elasticProperty.fieldIndex().equals(FieldIndexOption.ANALYZED)) &#123; type = &quot;text&quot;; &#125; else &#123; type = &quot;keyword&quot;; &#125; &#125; else if (fieldType.equals(Integer.class)) &#123; type = &quot;integer&quot;; &#125; else if (fieldType.equals(Long.class)) &#123; type = &quot;long&quot;; &#125; else if (fieldType.equals(Double.class)) &#123; type = &quot;double&quot;; &#125; else if (fieldType.equals(Float.class)) &#123; type = &quot;float&quot;; &#125; else if (fieldType.equals(Boolean.class)) &#123; type = &quot;boolean&quot;; &#125; else if (fieldType.equals(Byte.class)) &#123; type = &quot;binary&quot;; &#125; else if (fieldType.equals(Date.class)) &#123; type = &quot;date&quot;; &#125; else &#123; //如果是Nested dataType类型则需要重新赋值 if (elasticProperty!=null &amp;&amp; elasticProperty.isNested().equals(NestOpinion.NESTED)) &#123; //注意此时isNested参数为true return generateSource(fieldType, fieldName, true); &#125; //Object dataType：自定义类型字段，使用递归获取该field的source return generateSource(fieldType, fieldName, false); &#125; //单个字段上定义的参数信息 StringBuilder parameters = new StringBuilder(); parameters.append(parameterPattern.replace(&quot;$parameterName&quot;, &quot;type&quot;).replace(&quot;$parameterValue&quot;, type)); if (elasticProperty != null) &#123; if (type.equals(&quot;fulltext&quot;)) &#123; String analyzer = elasticProperty.analyzer(); parameters.append(&quot;, &quot;) .append(parameterPattern.replace(&quot;$parameterName&quot;, &quot;analyzer&quot;).replace(&quot;$parameterValue&quot;, analyzer)); &#125; if (type.equals(&quot;keyword&quot;) || type.equals(&quot;date&quot;)) &#123; String nullValue = elasticProperty.nullValue(); parameters.append(&quot;, &quot;) .append(parameterPattern.replace(&quot;$parameterName&quot;, &quot;null_value&quot;).replace(&quot;$parameterValue&quot;, nullValue)); &#125; if (type.equals(&quot;date&quot;)) &#123; String dateFormat = elasticProperty.dateFormat(); parameters.append(&quot;, &quot;) .append(parameterPattern.replace(&quot;$parameterName&quot;, &quot;format&quot;).replace(&quot;$parameterValue&quot;, dateFormat)); &#125; if (!StringUtils.isEmpty(elasticProperty.fields())) &#123; parameters.append(&quot;, &quot;) .append(fieldsPattern.replace(&quot;$fieldsValue&quot;, elasticProperty.fields())); &#125; &#125; String result = propertyPattern.replace(&quot;$fieldName&quot;, fieldName).replace(&quot;$parameters&quot;, parameters.toString()); return result; &#125;&#125; ESClientHelper中实现创建index的方法12345678910111213141516171819public static boolean createIndex(Client client, String index, Settings.Builder settings, String type, String mapping)&#123; if (client==null || StringUtils.isEmpty(index) || StringUtils.isEmpty(mapping) || indexExists(client, index))&#123; return false; &#125; if (settings == null)&#123; settings = Settings.builder() .put(&quot;index.number_of_shards&quot;, 5) .put(&quot;index.number_of_replicas&quot;, 2); &#125; CreateIndexResponse createIndexResponse = client.admin().indices() .prepareCreate(index) .setSettings(settings) .get(); if (!createIndexResponse.isAcknowledged())&#123; return false; &#125; PutMappingResponse putMappingResponse = client.admin().indices().preparePutMapping(index).setType(type).setSource(mapping, XContentType.JSON).get(); return putMappingResponse.isAcknowledged(); &#125; 测试123456789101112131415161718@RunWith(SpringRunner.class)@SpringBootTestpublic class ESClientHelperTest &#123; @Autowired private Environment env; @Test public void testCreateIndex()&#123; Client client = ESClientHelper.getClient(env.getProperty(&quot;elasticsearch.cluster-name2&quot;)); String index = env.getProperty(&quot;elasticsearch.index-name&quot;); String mapping = ElasticsearchMappingGenerator.generateSource(Department.class, null, false); if (ESClientHelper.createIndex(client, index, null, &quot;department&quot;, mapping))&#123; System.out.println(&quot;success creating index&quot;); &#125;else&#123; System.out.println(&quot;fail to create index&quot;); &#125; &#125;&#125; 插入数据ESClientHelper中实现insert方法1234567public static String insert(Client client, String index, String type, Object object)&#123; String json = JSONObject.toJSONString(object); IndexResponse response = client.prepareIndex(index, type) .setSource(json, XContentType.JSON) .get(); return response.getId();&#125; 测试12345678910111213141516171819202122232425262728@Testpublic void testInsert() throws Exception&#123; Client client = ESClientHelper.getClient(env.getProperty(&quot;elasticsearch.cluster-name2&quot;)); String index = env.getProperty(&quot;elasticsearch.index-name&quot;); Department department = new Department(); List&lt;Employee&gt; employees = new ArrayList&lt;&gt;(); Employee employee = new Employee(); employee.setName(&quot;wfw&quot;); employee.setAge(29); employee.setBirth(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).parse(&quot;1989-08-01&quot;)); employee.setProfile(&quot;职场菜鸟&quot;); List&lt;String&gt; articles = new ArrayList&lt;&gt;(); articles.add(&quot;SpringBoot系列&quot;); articles.add(&quot;机器学习了解&quot;); employee.setArticles(articles); employees.add(employee); department.setDepartmentName(&quot;技术部&quot;); department.setEmployees(employees); List&lt;Business&gt; businessList = new ArrayList&lt;&gt;(); Business business = new Business(); business.setCore(&quot;司法&quot;); business.setRevenue(new Float(10000000.0)); businessList.add(business); department.setBusinessList(businessList); System.out.println(ESClientHelper.insert(client, index, &quot;department&quot;, department));&#125; 参考文章 TransportClient Indices Administration]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot系列（六）——集成redis]]></title>
    <url>%2F2018%2F04%2F03%2FSpringBoot%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E9%9B%86%E6%88%90redis%2F</url>
    <content type="text"><![CDATA[redis经常用于缓存用户登录信息，本文介绍SpringBoot如何集成单节点的redis及redis集群。 环境依赖pom.xml文件中增加启动依赖项1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; redis在application.properties中配置说明123456789101112131415161718192021222324252627282930# （普通集群，不使用则不用开启）在群集中执行命令时要遵循的最大重定向数目。# spring.redis.cluster.max-redirects=# （普通集群，不使用则不用开启）以逗号分隔的“主机：端口”对列表进行引导。# spring.redis.cluster.nodes=# 连接工厂使用的数据库索引。spring.redis.database=0# 连接URL，将覆盖主机，端口和密码（用户将被忽略），例如：redis://user:password@example.com:6379spring.redis.url=# Redis服务器主机。spring.redis.host=localhost# 登录redis服务器的密码。spring.redis.password=# 启用SSL支持。spring.redis.ssl=false# 池在给定时间可以分配的最大连接数。使用负值无限制。spring.redis.pool.max-active=8# 池中“空闲”连接的最大数量。使用负值表示无限数量的空闲连接。spring.redis.pool.max-idle=8# 连接分配在池被耗尽时抛出异常之前应该阻塞的最长时间量（以毫秒为单位）。使用负值可以无限期地阻止。spring.redis.pool.max-wait=-1# 目标为保持在池中的最小空闲连接数。这个设置只有在正面的情况下才有效果。spring.redis.pool.min-idle=0# Redis服务器端口。spring.redis.port=6379# （哨兵模式，不使用则不用开启）Redis服务器的名称。# spring.redis.sentinel.master=# （哨兵模式，不使用则不用开启）主机：端口对的逗号分隔列表。 # spring.redis.sentinel.nodes=# 以毫秒为单位的连接超时。spring.redis.timeout=0 redis配置在application.properties中增加redis相关配置1234567891011# redis单点配置#spring.redis.host=10.202.xx.xx#spring.redis.port=30301#spring.redis.database=10#spring.redis.password=password#spring.redis.timeout=28800# redis集群配置spring.redis.cluster.nodes=10.203.xx.1:7000,10.203.xx.1:7001,10.203.xx.1:7002,10.203.xx.1:7003,10.203.xx.1:7004,10.203.xx.1:7005spring.redis.password=passwordspring.redis.timeout=28800 实现工具类12345678910111213141516171819202122232425262728293031323334@Componentpublic class RedisUtil &#123; @Autowired private RedisTemplate&lt;String, String&gt; redisTemplate; @Autowired private Environment env; public &lt;T&gt; T get(String key, Class&lt;T&gt; clz) &#123; String value = redisTemplate.opsForValue().get(key); if (value == null) return null; return JSONObject.parseObject(value, clz); &#125; public String get(String key)&#123; return redisTemplate.opsForValue().get(key); &#125; public void set(String key, Object value, long timeout) &#123; String json = JSONObject.toJSONString(value); redisTemplate.opsForValue().set(key, json, timeout, TimeUnit.MILLISECONDS); &#125; public void set(String key, Object value)&#123; int timeout = env.getProperty(&quot;spring.redis.timeout&quot;, Integer.class); String json = JSONObject.toJSONString(value); redisTemplate.opsForValue().set(key, json, timeout, TimeUnit.MILLISECONDS); &#125; public void delete(String key) &#123; redisTemplate.delete(key); &#125;&#125; 测试12345678910111213141516171819202122232425262728@RunWith(SpringRunner.class)@SpringBootTestpublic class RedisUtilTest &#123; @Autowired private RedisUtil redisUtil; @Test public void testRedisUtil()&#123; //设置redis String key = UUID.randomUUID().toString(); redisUtil.set(key, &quot;this is a redis test without timeout&quot;); //取值 String value = redisUtil.get(key); System.out.println(value); //删除key redisUtil.delete(key); value = redisUtil.get(key); System.out.println(value); key = UUID.randomUUID().toString(); UserDTO userDTO = new UserDTO(); userDTO.setUserName(&quot;wfw&quot;); userDTO.setDepartment(&quot;tech&quot;); redisUtil.set(key, userDTO, 1); UserDTO userValue = redisUtil.get(key, UserDTO.class); System.out.println(userValue.getUserName() + &quot;: &quot; + userValue.getDepartment()); &#125;&#125; 参考文章 Springboot揭秘与实战——redis Centos7搭建redis集群及安装sentinel]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot系列（五）——全局异常处理]]></title>
    <url>%2F2018%2F04%2F03%2FSpringBoot%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[对于代码中未捕获的异常，需要有一个全局异常处理器。 实现1234567891011121314@RestControllerAdvicepublic class GlobalExceptionHandler &#123; private Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class); @ExceptionHandler(&#123;Exception.class&#125;) @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) public BaseResponseVO unknownException(Exception e) &#123; this.logger.error(String.format(&quot;Global catch unknown exception , message: %s&quot;, e.getMessage()), e); BaseResponseVO result = new BaseResponseVO(); result.setMessage(&quot;服务器错误&quot;); result.setResult(false); return result; &#125;&#125; 将异常记录到日志中 测试12345@RequestMapping(path = &quot;testGlobalExceptionHandler&quot;, method = RequestMethod.GET)@ApiOperation(value = &quot;测试全局异常处理&quot;)public BaseResponseVO testGlobalExceptionHandler() throws Exception&#123; throw new Exception(&quot;this is a global exception handler test&quot;);&#125;]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java构造函数初始化]]></title>
    <url>%2F2018%2F04%2F01%2FJava%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[通过代码看一下java中父子类直接构造函数的初始化顺序。 说明语法 如果类没有提供构造函数，则会生成默认的无参构造函数 父类的构造函数必须被子类构造函数隐式调用或显示调用 如果父类提供了无参构造函数，则子类可以选择隐式调用父类的构造函数（即调用父类的无参构造函数），或者显示调用父类构造函数（可以显示调用父类的无参构造函数，也可以显示调用父类的有参构造函数） 如果父类只提供了有参构造函数，则子类必须显示调用父类的有参构造函数 初始化顺序 父类静态变量 -&gt; 父类静态代码块 -&gt; 子类静态变量 -&gt; 子类静态代码块因为静态代码块中只能访问静态变量，因此静态变量要在静态代码块之前初始化 父类非静态变量 -&gt; 父类非静态代码块 -&gt; 父类构造函数 子类非静态代码块 -&gt; 子类非静态变量 -&gt; 子类构造函数 测试定义父类：123456789101112131415161718192021public class ClassA &#123; private final static String parentStaticVariable = &quot;parentStaticVariableValue&quot;; private String parentVariable = &quot;parentVariableValue&quot;; static &#123; System.out.println(&quot;parentStaticVariableValue: &quot; + parentStaticVariable); System.out.println(&quot;ClassA static code block&quot;); &#125; &#123; System.out.println(&quot;parentVariable: &quot; + parentVariable); System.out.println(&quot;ClassA code block&quot;); &#125; public ClassA()&#123; System.out.println(&quot;ClassA&apos;s constructor with no parameters&quot;); &#125; public ClassA(String para)&#123; System.out.println(&quot;ClassA&apos;s constructor with parameters: &quot; + para); &#125;&#125; 定义子类：12345678910111213141516171819202122public class ClassB extends ClassA &#123; private final static String childStaticVariable = &quot;childStaticVariableValue&quot;; private String childVariable = &quot;childVariableValue&quot;; static &#123; System.out.println(&quot;childStaticVariable: &quot; + childStaticVariable); System.out.println(&quot;ClassB static code block&quot;); &#125; &#123; System.out.println(&quot;childVariable: &quot; + childVariable); System.out.println(&quot;ClassB block code&quot;); &#125; public ClassB()&#123; System.out.println(&quot;ClassB&apos;s constructor with no parameters&quot;); &#125; public ClassB(String para)&#123; super(para); System.out.println(&quot;ClassB&apos;s constructor with parameters: &quot; + para); &#125;&#125; 测试：12345public void testConstructor()&#123; ClassB classB = new ClassB(); System.out.println(&quot;---------------------------------------------------&quot;); classB = new ClassB(&quot;ClassB构造参数&quot;);&#125; 参考文章 Java构造函数之调用父类构造函数]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>构造函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解Spring中的beanFactory]]></title>
    <url>%2F2018%2F03%2F26%2F%E7%90%86%E8%A7%A3Spring%E4%B8%AD%E7%9A%84beanFactory%2F</url>
    <content type="text"><![CDATA[IOC（Inversion of Control）即“控制反转”，是一种思想，将创建对象的权利交给框架（或容器）。而DI（Dependency Injection）即依赖注入是其实现的一种方式，还包括DL（Dependency Lookup）即依赖查找。 由来Interface Driven Design即接口驱动可以提供灵活的子类实现，但接口一定要实现。假设定义了接口AInterface，其实现为AInterfaceImpl，那么使用时需要实例化：AInterface a = new AInterfaceImpl()，那么这样接口和接口实现直接的依赖和耦合关系就产生了:123456789classA&#123; AInterface a; A()&#123;&#125; AMethod()//一个方法 &#123; a = new AInterfaceImp(); &#125;&#125; Class A与AInterfaceImp就是依赖关系，如果想使用AInterface的另外一个实现就需要更改代码了。这时我们可以使用工厂模式根据条件获取AInterface的不同实现:123456789101112131415161718InterfaceImplFactory&#123; AInterface create(Object condition) &#123; if(condition == condA) &#123; return new AInterfaceImpA(); &#125; else if(condition == condB) &#123; return new AInterfaceImpB(); &#125; else &#123; return new AInterfaceImp(); &#125; &#125;&#125; 但是很显然，代码直接的耦合仍然存在，假设新增一种实现，还需要修改工厂。通过IoC模式可以彻底解决这种耦合，它把耦合从代码中移出去，放到统一的XML文件中，通过一个容器在需要的时候把这个依赖关系形成。由IoC容器管理对象的生命周期、依赖关系等。可以通过文本的配置文件进行应用程序组件间相互关系的配置，而不用重新修改并编译具体的代码。Spring就是一个IoC容器。可以把IoC模式看做是工厂模式的升华，把IoC看作是一个大工厂，只不过这个大工厂里要生成的对象都是在XML文件中给出定义的，然后利用Java的“反射”编程，根据XML中给出的类名生成相应的对象。从实现来看，IoC是把以前在工厂方法里写死的对象生成代码，改变为由XML文件来定义，也就是把工厂和对象生成这两者独立分隔开来，目的就是提高灵活性和可维护性。优点：因为把对象生成放在了XML里定义，所以当我们需要换一个实现子类将会变成很简单（一般这样的对象都是实现于某种接口的），只要修改XML就可以了，这样我们甚至可以实现对象的热插拔缺点：（1）生成一个对象的步骤变“复杂”了（2）由于使用反射，效率降低（3）缺少IDE重构操作的支持，如果在Eclipse要对类改名，那么你还需要去XML文件里手工去改了。 我的理解：IoC容器将服务或组件的实现定义到bean中（以xml文件或注解的方式等），然后通过beanFactory实现将其注入容器中，由容器控制对象的生命周期和依赖关系等。 实现简单基于xml的beanFactory定义MyXmlBeanFactory123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class MyXmlBeanFactory &#123; private Map&lt;String, Object&gt; container = new HashMap&lt;&gt;(); public MyXmlBeanFactory(String... xmlPaths) throws DocumentException, ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchFieldException &#123; for (String xmlPath : xmlPaths) &#123; // 读取指定的配置文件 SAXReader reader = new SAXReader(); ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); // 从class目录下获取指定的xml文件 InputStream ins = classLoader.getResourceAsStream(xmlPath); Document doc = reader.read(ins); Element root = doc.getRootElement(); Element foo; // 遍历bean for (Iterator i = root.elementIterator(&quot;bean&quot;); i.hasNext(); ) &#123; foo = (Element) i.next(); // 获取bean的属性id和class Attribute id = foo.attribute(&quot;id&quot;); Attribute cls = foo.attribute(&quot;class&quot;); // 利用Java反射机制，通过class的名称获取Class对象 Class&lt;?&gt; bean = Class.forName(cls.getText()); // 创建一个对象 Object obj = bean.newInstance(); // 遍历该bean的property属性 for (Iterator ite = foo.elementIterator(&quot;property&quot;); ite.hasNext(); ) &#123; Element foo2 = (Element) ite.next(); // 获取该property的name属性 Attribute name = foo2.attribute(&quot;name&quot;); Object value; if (container.containsKey(name.getText())) &#123; value = container.get(name.getText()); Field field = bean.getDeclaredField(name.getText()); field.setAccessible(true); field.set(obj, value); &#125; &#125; // 将对象放入beanMap中，其中key为id值，value为对象 container.put(id.getText(), obj); &#125; &#125; &#125; public Object getBean(String beanName) &#123; Object obj = this.container.get(beanName); return obj; &#125;&#125; 定义接口及实现定义BInterface接口：123public interface BInterface &#123; String say();&#125; 定义BInterface接口的实现BInterfaceImpl:123456public class BInterfaceImpl implements BInterface &#123; @Override public String say() &#123; return &quot;this is a hello from BInterface&quot;; &#125;&#125; 定义AInterface接口：123public interface AInterface &#123; void print();&#125; 定义AInterface接口的实现AInterfaceImpl，其实现依赖于BInterface:123456789101112131415161718public class AInterfaceImpl implements AInterface &#123; private BInterface bInterface; public BInterface getbInterface() &#123; return bInterface; &#125; //beans.xml使用的是依赖注入，依赖注入必须写setter方法 public void setbInterface(BInterface bInterface) &#123; this.bInterface = bInterface; &#125; @Override public void print() &#123; System.out.println(&quot;this is an implementation of AInterface, it&apos;s dependency bInterface say: &quot; + bInterface.say()); &#125;&#125; 定义xml配置bean在resources/study目录下创建beans.xml12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt; &lt;bean id=&quot;bInterface&quot; class=&quot;com.wfw.study.ioc.xml.BInterfaceImpl&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;aInterface&quot; class=&quot;com.wfw.study.ioc.xml.AInterfaceImpl&quot;&gt; &lt;property name=&quot;bInterface&quot; ref=&quot;bInterface&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 测试12345678910111213141516public class MyBeanFactoryTest extends TestCase &#123; public void testApplicationContext()&#123; //测试ClassPathXmlApplicationContext ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;study/beans.xml&quot;); BInterface bInterface = (BInterface) ac.getBean(&quot;bInterface&quot;); System.out.println(bInterface.say()); ((AInterface) ac.getBean(&quot;aInterface&quot;)).print(); &#125; public void testBeanFactory() throws Exception &#123; MyXmlBeanFactory myXmlBeanFactory = new MyXmlBeanFactory(&quot;study/beans.xml&quot;); BInterface bInterface = (BInterface) myXmlBeanFactory.getBean(&quot;bInterface&quot;); System.out.println(bInterface.say()); ((AInterface) myXmlBeanFactory.getBean(&quot;aInterface&quot;)).print(); &#125;&#125; 我们的测试使用了ClassPathXmlApplicationContext用来对比，可以看到输出结果一致。 实现基于注解的beanFactory自定义注解@MyComponent对应Spring中的@Component该注解用于注解class，被注解的类表明是一个组件。当IoC使用基于注解的配置和classpath扫描时，被@MyComponent注解的类可以被自动检测到。12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface MyComponent &#123; /** * 组件名称 * @return */ String value() default &quot;&quot;;&#125; 自定义注解@MyResource对应jdk中的@Resource，JDK中的注解可以用于注解Class，Field和Method，此处我们只用于注解Field。当IoC容器实例化组件时，组件中如果有被该注解注释的Field，则IoC容器会将实例化的Field注入到该组件中。12345678910@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface MyResource &#123; /** * 默认是field名称 * @return */ String name() default &quot;&quot;;&#125; 使用自定义注解定义组件自定义B组件的接口定义123public interface BComponentInterface &#123; String say();&#125; 自定义B组件的接口实现1234567@MyComponentpublic class BComponentImpl implements BComponentInterface &#123; @Override public String say() &#123; return &quot;this is a hello from BComponentInterface&quot;; &#125;&#125; 自定义组件A12345678910@MyComponentpublic class AComponent &#123; @MyResource(name = &quot;bComponentImpl&quot;) private BComponentInterface bComponent; public void print()&#123; System.out.println(&quot;this is an AComponent, it&apos;s dependency bComponent say: &quot; + bComponent.say()); &#125;&#125; 实现基于注解的beanFactory思路：指定包的扫描路径，在classPath中扫描.class文件，然后基于@Component注解进行筛选，实例化后放入container，然后注入每个实例化组件中被@MyResource注释的Field。getBean方法从container中取出实例。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public class MyAnnotationBeanFactory &#123; private Map&lt;String, Object&gt; container = new HashMap&lt;&gt;(); private String classPath = &quot;&quot;; public MyAnnotationBeanFactory(String... basePackages) throws ClassNotFoundException, InstantiationException, IllegalAccessException, FieldInjectionFailedException &#123; this.classPath = MyAnnotationBeanFactory.class.getClassLoader().getResource(&quot;&quot;).getPath(); //因为是在单元测试中测试的，所有路径需要替换一下 this.classPath = this.classPath.replace(&quot;test-classes&quot;, &quot;classes&quot;); String systemName = System.getProperty(&quot;os.name&quot;); if (systemName.startsWith(&quot;Win&quot;)) &#123; this.classPath = this.classPath.substring(1); &#125; //扫描所有basePackages下的.class文件到classFiles List&lt;File&gt; classFiles = new ArrayList&lt;&gt;(); for (String basePackage : basePackages) &#123; String packagePath = basePackage.replace(&quot;.&quot;, &quot;/&quot;); File folder = Paths.get(this.classPath, packagePath).toFile(); this.scanClass(folder, classFiles); &#125; this.instantiateComponent(classFiles); this.injectField(); &#125; public Object getBean(String beanName)&#123; Object obj = this.container.get(beanName); return obj; &#125; /** * 获取文件夹下所有的.class文件 * * @param folder * @return */ private void scanClass(File folder, List&lt;File&gt; list) &#123; for (File f : folder.listFiles()) &#123; if (f.isFile() &amp;&amp; f.getName().endsWith(&quot;.class&quot;)) &#123; list.add(f); &#125; else if (!f.isFile()) &#123; scanClass(f, list); &#125; &#125; &#125; /** * 实例化被@Component注解的组件 * * @param classFiles */ private void instantiateComponent(List&lt;File&gt; classFiles) throws ClassNotFoundException, InstantiationException, IllegalAccessException &#123; ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); for (File classFile : classFiles) &#123; //获取类名并实例化 String className = classFile.getAbsolutePath().substring(0, classFile.getAbsolutePath().length() - 6) .replace(&quot;\\&quot;, &quot;/&quot;) .replace(this.classPath, &quot;&quot;).replace(&quot;/&quot;, &quot;.&quot;); Class&lt;?&gt; clazz = classLoader.loadClass(className); //如果该类被@MyComponent注解，则实例化并保存到container if (clazz.isAnnotationPresent(MyComponent.class)) &#123; //获取@MyComponent注解及其value MyComponent myComponent = clazz.getAnnotation(MyComponent.class); String componentName = myComponent.value(); if (componentName.equals(&quot;&quot;)) &#123; //@MyComponent的value为空时，使用类名作为id，类名首字母小写 componentName = clazz.getSimpleName(); componentName = componentName.substring(0, 1).toLowerCase() + componentName.substring(1); &#125; if (!this.container.containsKey(componentName))&#123; this.container.put(componentName, clazz.newInstance()); &#125; &#125; &#125; &#125; /** * 自动注入组件中依赖的由@MyResource注解注释的Field */ private void injectField() throws FieldInjectionFailedException, IllegalAccessException&#123; Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; iterator = this.container.entrySet().iterator(); //遍历所有被实例化的组件 while (iterator.hasNext())&#123; Map.Entry&lt;String, Object&gt; entry = iterator.next(); Object component = entry.getValue(); //找出所有被@MyResource注解注释的Field for(Field field : component.getClass().getDeclaredFields())&#123; if (field.isAnnotationPresent(MyResource.class))&#123; //提取@MyResource中的name MyResource myResource = field.getAnnotation(MyResource.class); String myResourceName = myResource.name(); if (myResourceName.equals(&quot;&quot;))&#123; myResourceName = field.getName(); &#125; if (!this.container.containsKey(myResourceName))&#123; throw new FieldInjectionFailedException(component.getClass().getName() + &quot;的&quot; + field.getName() + &quot;注入失败&quot;); &#125; field.setAccessible(true); field.set(component, this.container.get(myResourceName)); &#125; &#125; &#125; &#125;&#125; 测试1234567public void testAnnotationBeanFactory() throws Exception &#123; MyAnnotationBeanFactory myAnnotationBeanFactory = new MyAnnotationBeanFactory(&quot;com.wfw.study.ioc.annotation&quot;); BComponentInterface bComponentInterface = (BComponentInterface)myAnnotationBeanFactory.getBean(&quot;bComponentImpl&quot;); System.out.println(bComponentInterface.say()); AComponent aComponent = (AComponent)myAnnotationBeanFactory.getBean(&quot;aComponent&quot;); aComponent.print(); &#125; 源码解读SpringBoot中beanFactory的继承关系我把beanFactory接口的继承关系和具体实现类用红框框起来了。可以看一下AbstractApplicationContext中对BeanFactory接口的具体实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//---------------------------------------------------------------------// Implementation of BeanFactory interface//---------------------------------------------------------------------@Overridepublic Object getBean(String name) throws BeansException &#123; assertBeanFactoryActive(); return getBeanFactory().getBean(name);&#125;@Overridepublic &lt;T&gt; T getBean(String name, @Nullable Class&lt;T&gt; requiredType) throws BeansException &#123; assertBeanFactoryActive(); return getBeanFactory().getBean(name, requiredType);&#125;@Overridepublic Object getBean(String name, Object... args) throws BeansException &#123; assertBeanFactoryActive(); return getBeanFactory().getBean(name, args);&#125;@Overridepublic &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException &#123; assertBeanFactoryActive(); return getBeanFactory().getBean(requiredType);&#125;@Overridepublic &lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException &#123; assertBeanFactoryActive(); return getBeanFactory().getBean(requiredType, args);&#125;@Overridepublic boolean containsBean(String name) &#123; return getBeanFactory().containsBean(name);&#125;@Overridepublic boolean isSingleton(String name) throws NoSuchBeanDefinitionException &#123; assertBeanFactoryActive(); return getBeanFactory().isSingleton(name);&#125;@Overridepublic boolean isPrototype(String name) throws NoSuchBeanDefinitionException &#123; assertBeanFactoryActive(); return getBeanFactory().isPrototype(name);&#125;@Overridepublic boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException &#123; assertBeanFactoryActive(); return getBeanFactory().isTypeMatch(name, typeToMatch);&#125;@Overridepublic boolean isTypeMatch(String name, @Nullable Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException &#123; assertBeanFactoryActive(); return getBeanFactory().isTypeMatch(name, typeToMatch);&#125;@Override@Nullablepublic Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException &#123; assertBeanFactoryActive(); return getBeanFactory().getType(name);&#125;@Overridepublic String[] getAliases(String name) &#123; return getBeanFactory().getAliases(name);&#125; AbstractApplicationContext中对ListableBeanFactory接口的具体实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//---------------------------------------------------------------------// Implementation of ListableBeanFactory interface//---------------------------------------------------------------------@Overridepublic boolean containsBeanDefinition(String beanName) &#123; return getBeanFactory().containsBeanDefinition(beanName);&#125;@Overridepublic int getBeanDefinitionCount() &#123; return getBeanFactory().getBeanDefinitionCount();&#125;@Overridepublic String[] getBeanDefinitionNames() &#123; return getBeanFactory().getBeanDefinitionNames();&#125;@Overridepublic String[] getBeanNamesForType(ResolvableType type) &#123; assertBeanFactoryActive(); return getBeanFactory().getBeanNamesForType(type);&#125;@Overridepublic String[] getBeanNamesForType(@Nullable Class&lt;?&gt; type) &#123; assertBeanFactoryActive(); return getBeanFactory().getBeanNamesForType(type);&#125;@Overridepublic String[] getBeanNamesForType(@Nullable Class&lt;?&gt; type, boolean includeNonSingletons, boolean allowEagerInit) &#123; assertBeanFactoryActive(); return getBeanFactory().getBeanNamesForType(type, includeNonSingletons, allowEagerInit);&#125;@Overridepublic &lt;T&gt; Map&lt;String, T&gt; getBeansOfType(@Nullable Class&lt;T&gt; type) throws BeansException &#123; assertBeanFactoryActive(); return getBeanFactory().getBeansOfType(type);&#125;@Overridepublic &lt;T&gt; Map&lt;String, T&gt; getBeansOfType(@Nullable Class&lt;T&gt; type, boolean includeNonSingletons, boolean allowEagerInit) throws BeansException &#123; assertBeanFactoryActive(); return getBeanFactory().getBeansOfType(type, includeNonSingletons, allowEagerInit);&#125;@Overridepublic String[] getBeanNamesForAnnotation(Class&lt;? extends Annotation&gt; annotationType) &#123; assertBeanFactoryActive(); return getBeanFactory().getBeanNamesForAnnotation(annotationType);&#125;@Overridepublic Map&lt;String, Object&gt; getBeansWithAnnotation(Class&lt;? extends Annotation&gt; annotationType) throws BeansException &#123; assertBeanFactoryActive(); return getBeanFactory().getBeansWithAnnotation(annotationType);&#125;@Override@Nullablepublic &lt;A extends Annotation&gt; A findAnnotationOnBean(String beanName, Class&lt;A&gt; annotationType) throws NoSuchBeanDefinitionException&#123; assertBeanFactoryActive(); return getBeanFactory().findAnnotationOnBean(beanName, annotationType);&#125; AbstractApplicationContext中对HierarchicalBeanFactory接口的具体实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//---------------------------------------------------------------------// Implementation of HierarchicalBeanFactory interface//---------------------------------------------------------------------@Override@Nullablepublic BeanFactory getParentBeanFactory() &#123; return getParent();&#125;@Overridepublic boolean containsLocalBean(String name) &#123; return getBeanFactory().containsLocalBean(name);&#125;/** * Return the internal bean factory of the parent context if it implements * ConfigurableApplicationContext; else, return the parent context itself. * @see org.springframework.context.ConfigurableApplicationContext#getBeanFactory */@Nullableprotected BeanFactory getInternalParentBeanFactory() &#123; return (getParent() instanceof ConfigurableApplicationContext) ? ((ConfigurableApplicationContext) getParent()).getBeanFactory() : getParent();&#125;//---------------------------------------------------------------------// Implementation of MessageSource interface//---------------------------------------------------------------------@Overridepublic String getMessage(String code, @Nullable Object args[], @Nullable String defaultMessage, Locale locale) &#123; return getMessageSource().getMessage(code, args, defaultMessage, locale);&#125;@Overridepublic String getMessage(String code, @Nullable Object args[], Locale locale) throws NoSuchMessageException &#123; return getMessageSource().getMessage(code, args, locale);&#125;@Overridepublic String getMessage(MessageSourceResolvable resolvable, Locale locale) throws NoSuchMessageException &#123; return getMessageSource().getMessage(resolvable, locale);&#125;/** * Return the internal MessageSource used by the context. * @return the internal MessageSource (never &#123;@code null&#125;) * @throws IllegalStateException if the context has not been initialized yet */private MessageSource getMessageSource() throws IllegalStateException &#123; if (this.messageSource == null) &#123; throw new IllegalStateException(&quot;MessageSource not initialized - &quot; + &quot;call &apos;refresh&apos; before accessing messages via the context: &quot; + this); &#125; return this.messageSource;&#125;/** * Return the internal message source of the parent context if it is an * AbstractApplicationContext too; else, return the parent context itself. */@Nullableprotected MessageSource getInternalParentMessageSource() &#123; return (getParent() instanceof AbstractApplicationContext) ? ((AbstractApplicationContext) getParent()).messageSource : getParent();&#125; 其实现基本都是通过调用getBeanFactory()方法获取beanFactory来间接实现。而在AbstractApplicationContext类中，该方法是一个抽象方法，需要由其子类实现。12@Override public abstract ConfigurableListableBeanFactory getBeanFactory() throws IllegalStateException; 我们再来看一下其继承类GenericApplicationContext对抽象方法getBeanFactory()的override：1234@Overridepublic final ConfigurableListableBeanFactory getBeanFactory() &#123; return this.beanFactory;&#125; 可以看到，该方法返回的是上下文的内部变量this.beanFactory，那么该变量是如何被实例化的？首先看它在GenericApplicationContext类中的定义：1private final DefaultListableBeanFactory beanFactory; 接下来看看它是如何在构造函数中被初始化的：123456789101112131415161718192021222324252627282930313233343536373839404142/** * Create a new GenericApplicationContext. * @see #registerBeanDefinition * @see #refresh */public GenericApplicationContext() &#123; this.beanFactory = new DefaultListableBeanFactory();&#125;/** * Create a new GenericApplicationContext with the given DefaultListableBeanFactory. * @param beanFactory the DefaultListableBeanFactory instance to use for this context * @see #registerBeanDefinition * @see #refresh */public GenericApplicationContext(DefaultListableBeanFactory beanFactory) &#123; Assert.notNull(beanFactory, &quot;BeanFactory must not be null&quot;); this.beanFactory = beanFactory;&#125;/** * Create a new GenericApplicationContext with the given parent. * @param parent the parent application context * @see #registerBeanDefinition * @see #refresh */public GenericApplicationContext(@Nullable ApplicationContext parent) &#123; this(); setParent(parent);&#125;/** * Create a new GenericApplicationContext with the given DefaultListableBeanFactory. * @param beanFactory the DefaultListableBeanFactory instance to use for this context * @param parent the parent application context * @see #registerBeanDefinition * @see #refresh */public GenericApplicationContext(DefaultListableBeanFactory beanFactory, ApplicationContext parent) &#123; this(beanFactory); setParent(parent);&#125; 可见类型为DefaultListableBeanFactory的beanFactory变量是实际的执行者。 beanDefinition的注册上述几个构造函数的注释中都提到了两个方法：registerBeanDefinition和registerBeanDefinition，我们先不管这两个方法是在什么时候，哪里被调用的，先看看它们的定义。在GenericApplicationContext类中找找这两个方法，找到了registerBeanDefinition方法：123456@Override public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException &#123; this.beanFactory.registerBeanDefinition(beanName, beanDefinition); &#125; 它调用了this.beanFactory的方法。refresh方法没有找到，因此去GenericApplicationContext的父类AbstractApplicationContext中找，终于找到了：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@Overridepublic void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // 为context刷新做准备，执行property sources的初始化 prepareRefresh(); // 在子类中实现刷新内置bean factory的操作 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // 配置bean factory的标准上下文特性，例如ClassLoader和post-processors prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Register bean processors that intercept bean creation. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons：实例化所有单例模式的bean finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(&quot;Exception encountered during context initialization - &quot; + &quot;cancelling refresh attempt: &quot; + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset &apos;active&apos; flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring&apos;s core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; 参考文章8详细讲述了在refresh()方法中bean定义是如何被注册的，可以在代码中跟一下。主要通过postProcessBeanFactory(beanFactory)，invokeBeanFactoryPostProcessors(beanFactory)和registerBeanPostProcessors(beanFactory)获取beanDefinition，将其填充到类DefaultListableBeanFactory的变量beanDefinitionMap中。看一下该变量的定义：12/** Map of bean definition objects, keyed by bean name */private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256); bean的创建和注入Bean对象的创建是在getBean方法被调用的时候发生的，而在Spring中有两个场景会触发getBean方法被调用: 单例模式并且是非延迟加载的对象，会在IOC容器初始化的时候被创建且初始化 非单例模式或者是延迟加载的对象，是应用第一次向容器索要该Bean对象的时候被创建且初始化 看一下refresh()方法中，在完成beanDefinition的注册之后，调用了finishBeanFactoryInitialization(beanFactory)方法，该方法完成应用程序上下文中beanFactory的初始化，初始化所有单例模式的bean对象。而该方法通过调用beanFactory的preInstantiateSingletons()方法完成实例化。参考文章10详细讲述了bean是如何被创建和依赖注入的。 最后说一下refresh()方法是在什么时候被调用的，在SpringBoot启动的run方法中，有一个refreshContext(context)的方法调用，跟一下就可以看到：1234protected void refresh(ApplicationContext applicationContext) &#123; Assert.isInstanceOf(AbstractApplicationContext.class, applicationContext); ((AbstractApplicationContext) applicationContext).refresh();&#125; 参考文章 spring中的BeanFactory与ApplicationContext的作用和区别 Spring：源码解读Spring IOC原理 Spring学习之bean的理解 简单实现Spring中BeanFactory原理 控制反转 注解方式实现Bean的注入 以注解方式模拟Spring的IoC,AOP Spring boot Bean加载源码分析 Spring初始化过程之invokeBeanFactoryPostProcessors Spring源码解析三：IOC容器的依赖注入]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>beanFactory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解SpringFactoriesLoader]]></title>
    <url>%2F2018%2F03%2F23%2F%E7%90%86%E8%A7%A3SpringFactoriesLoader%2F</url>
    <content type="text"><![CDATA[SpringFactoriesLoader是Springframework框架中经常用到的一个类，在看SpringBoot源码前需要先了解一下它的作用以及工作原理。 作用General purpose factory loading mechanism for internal use within the framework即该类是为框架内部使用工厂加载机制服务的。SpringFactoriesLoader loads and instantiates factories of a given type from FACTORIES_RESOURCE_LOCATION files which may be present in multiple JAR files in the classpath.SpringFactoriesLoader类通过读取spring.factories文件（该文件会存在多个classpath的多个jar包中），对给定的type及factoryClass加载和实例化其工厂类。The spring.factories file must be in java.util.Properties format, where the key is the fully qualified name of the interface or abstract class, and the value is a comma-separated list of implementation class names.spring.factories格式：key为接口或抽象类全称，value为具体实现类全称的列表，举例如下：123456# Application Context Initializersorg.springframework.context.ApplicationContextInitializer=\org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\org.springframework.boot.context.ContextIdApplicationContextInitializer,\org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer ApplicationContextInitializer为接口名称，列表中为该接口的四个实现类。 为什么叫工厂加载机制呢？想一下工厂模式，工厂模式定义了一个接口或抽象类，然后用多个具体类去实现，通过传入不同的参数实现不同的实例化从而实现不同的功能。是不是跟spring.factories文件相对应。 源码分析SpringFactoriesLoader类的源码相对较简单，我们全部给出来12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public abstract class SpringFactoriesLoader &#123; public static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;; private static final Log logger = LogFactory.getLog(SpringFactoriesLoader.class); private static final Map&lt;ClassLoader, MultiValueMap&lt;String, String&gt;&gt; cache = new ConcurrentReferenceHashMap&lt;&gt;(); public static &lt;T&gt; List&lt;T&gt; loadFactories(Class&lt;T&gt; factoryClass, @Nullable ClassLoader classLoader) &#123; Assert.notNull(factoryClass, &quot;&apos;factoryClass&apos; must not be null&quot;); ClassLoader classLoaderToUse = classLoader; if (classLoaderToUse == null) &#123; classLoaderToUse = SpringFactoriesLoader.class.getClassLoader(); &#125; List&lt;String&gt; factoryNames = loadFactoryNames(factoryClass, classLoaderToUse); if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Loaded [&quot; + factoryClass.getName() + &quot;] names: &quot; + factoryNames); &#125; List&lt;T&gt; result = new ArrayList&lt;&gt;(factoryNames.size()); for (String factoryName : factoryNames) &#123; result.add(instantiateFactory(factoryName, factoryClass, classLoaderToUse)); &#125; AnnotationAwareOrderComparator.sort(result); return result; &#125; public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123; String factoryClassName = factoryClass.getName(); return loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList()); &#125; private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123; MultiValueMap&lt;String, String&gt; result = cache.get(classLoader); if (result != null) return result; try &#123; Enumeration&lt;URL&gt; urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION)); result = new LinkedMultiValueMap&lt;&gt;(); while (urls.hasMoreElements()) &#123; URL url = urls.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123; List&lt;String&gt; factoryClassNames = Arrays.asList( StringUtils.commaDelimitedListToStringArray((String) entry.getValue())); result.addAll((String) entry.getKey(), factoryClassNames); &#125; &#125; cache.put(classLoader, result); return result; &#125; catch (IOException ex) &#123; throw new IllegalArgumentException(&quot;Unable to load factories from location [&quot; + FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex); &#125; &#125; @SuppressWarnings(&quot;unchecked&quot;) private static &lt;T&gt; T instantiateFactory(String instanceClassName, Class&lt;T&gt; factoryClass, ClassLoader classLoader) &#123; try &#123; Class&lt;?&gt; instanceClass = ClassUtils.forName(instanceClassName, classLoader); if (!factoryClass.isAssignableFrom(instanceClass)) &#123; throw new IllegalArgumentException( &quot;Class [&quot; + instanceClassName + &quot;] is not assignable to [&quot; + factoryClass.getName() + &quot;]&quot;); &#125; return (T) ReflectionUtils.accessibleConstructor(instanceClass).newInstance(); &#125; catch (Throwable ex) &#123; throw new IllegalArgumentException(&quot;Unable to instantiate factory class: &quot; + factoryClass.getName(), ex); &#125; &#125; 常量FACTORIES_RESOURCE_LOCATION指定了加载文件的位置，即META-INF/spring.factories。SpringFactoriesLoader是一个抽象类，只能调用它的两个公共静态方法：loadFactories和loadFactoryNames loadFactoryNames方法定义：public static List&lt;String&gt; More ...loadFactoryNames(Class&lt;?&gt; factoryClass, ClassLoader classLoader){}factoryClass为工厂的接口或抽象类全称，即spring.factories中的keyclassLoader为类加载器，类加载器详解该方法获取spring.factories中指定key的value列表。该方法的起名容易让人误会，其实它获取的是具体实现类的全称。 loadFactories方法定义:public static &lt;T&gt; List&lt;T&gt; loadFactories(Class&lt;T&gt; factoryClass, @Nullable ClassLoader classLoader){}参数同loadFactoryNames方法。loadFactories方法首先调用loadFactoryNames方法获取待实例化的具体实现类的全称，然后调用instantiateFactory方法实例化每一个具体实现类，最终返回一个具体实现类的实例列表。 参考文章 SpringFactoriesLoader.java]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>java</tag>
        <tag>SpringFactoriesLoader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解Java中的ClassLoader]]></title>
    <url>%2F2018%2F03%2F22%2F%E7%90%86%E8%A7%A3Java%E4%B8%AD%E7%9A%84ClassLoader%2F</url>
    <content type="text"><![CDATA[一直不太理解java的类加载器，直到看到一篇通俗易懂的博客，特将自己的理解和实践记录下来。 概念理解认识.class文件我们写的java代码都是*.java文件，这就是源码。但是jvm是不认识.java文件的，需要用编译器javac将其编译为.class文件，它是一种字节码格式文件。 路径对于java，主要有三个路径：JAVA_HOME、PATH、CLASSPATH。JAVA_HOME：jdk的目录，这是一个基础目录PATH：这是实际的路径，主要记录jdk的bin目录和jre的bin目录，表示为PATH=%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;%PATH%;CLASSPATH：指向jar包的路径，表示为CLASSPATH=.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar 类加载流程java自带三个类加载器：BootstrapClassLoader，ExtentionClassLoader和AppclassLoader BootstrapClassLoader：最顶层的加载类，主要加载核心类库，%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar和class等。另外需要注意的是可以通过启动jvm时指定-Xbootclasspath和路径来改变Bootstrap ClassLoader的加载目录。比如java -Xbootclasspath/a:path被指定的文件追加到默认的bootstrap路径中。加载路径为：System.getProperty(&quot;sun.boot.class.path&quot;) ExtentionClassLoader：扩展的类加载器，加载目录%JRE_HOME%\lib\ext目录下的jar包和class文件。还可以加载-D java.ext.dirs选项指定的目录。加载路径为：System.getProperty(&quot;java.ext.dirs&quot;)&quot;) AppclassLoader：加载当前应用的classpath的所有类。加载路径为：System.getProperty(&quot;java.class.path&quot;) 加载顺序为：BootstrapClassLoader-&gt;ExtentionClassLoader-&gt;AppclassLoader 加载过程——双亲委托每个类加载器都有一个父加载器（有一个名为parent的变量，后面源码中会看到，注意不是父类）。一个类加载器查找class和resource时，是通过“委托模式”进行的，它首先判断这个class是不是已经加载成功，如果没有的话它并不是自己进行查找，而是先通过父加载器（如果父加载器为null，则jvm内置的加载器去替代，也就是Bootstrap ClassLoader。），然后递归下去，直到Bootstrap ClassLoader，如果Bootstrap classloader找到了，直接返回，如果没有找到，则一级一级返回，最后到达自身去查找这些对象。这种机制就叫做双亲委托。过程如图所示： 源码分析 Launcher.java它是一个java虚拟机的入口应用。从上图可以看到，2中初始化了ExtClassLoader，3中初始化了AppClassLoader，虽然没有看到BootstrapClassLoader，但1获取了其加载jar包的路径。上图可以看到，ExtClassLoader获取其加载jar包的路径后完成初始化上图可以看到，APPClassLoader获取其加载jar包后，用ExtClassLoader作为其父加载器完成初始化。 ClassLoader.java上面提到，父加载器不同与父类，那么父加载器是如何来的？首先看一张类的继承关系图12static class AppClassLoader extends URLClassLoader &#123;&#125;static class ExtClassLoader extends URLClassLoader &#123;&#125; 类加载器的getParent()方法可以获取父加载器，该方法从ClassLoader继承而来可以看到该方法实际上就是返回private parent私有变量，那么我们来看一下该私有变量是如何被赋值的：可以看到，如果类加载器的构造函数传入parent参数，则该类加载器的父加载器即为指定的parent；如果不传入parent参数，由getSystemClassLoader方法获取，则父加载器为AppClassLoader；如果为parent为null，则父加载器为BootstrapClassLoader。 重要方法——loadclass()12protected Class&lt;?&gt; loadClass(String name,boolean resolve) throws ClassNotFoundException 步骤： - 首先调用findLoadedClass(String)来检查是否已经加载类； - 如果未加载，则在父加载器上调用loadClass方法。如果父加载器为null，则使用虚拟机的内置类加载器。这也解释了ExtClassLoader的parent为null，但仍然说Bootstrap ClassLoader是它的父加载器； - 如果向上委托父加载器没有加载成功，调用findClass(String)方法查找类。 另外，要注意的是如果要编写一个classLoader的子类，也就是自定义一个classloader，建议覆盖findClass()方法，而不要直接改写loadClass()方法。 自定义类加载器——DiskClassLoader如上所述，BootstrapClassLoader加载核心类，ExtClassLoader加载扩展类，AppClassLoader加载target目录下的classes，如果我们想加载指定目录下的jar包中的类，可以实现一个自定义类加载器，步骤如下： 编写一个类继承自ClassLoader抽象类 复写它的findClass()方法 在findClass()方法中调用defineClass() 定义一个类Speak12345public class Speak &#123; public void say()&#123; System.out.println(&quot;the classloader speak&quot;); &#125;&#125; 将该类打成jar包，放到指定目录F:\testLib\lib 具体实现自定义类加载器： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/** * Created by killer9527 on 2018/3/21. * 自定义从硬盘加载类的类加载器 * 一个ClassLoader创建时如果没有指定parent，那么它的parent默认就是AppClassLoader。 */public class DiskClassLoader extends ClassLoader &#123; private String myLibPath; /** * 保存jar包中的.class文件的二进制字节 */ private Map&lt;String, byte[]&gt; clazzMap; public DiskClassLoader(String path) &#123; this.myLibPath = path; this.clazzMap = new HashMap&lt;&gt;(); readJarFile(); &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; String fileName = getFileName(name); try &#123; //1. 首先从classes/*.class文件中直接读取 File file = new File(Paths.get(this.myLibPath, &quot;classes&quot;).toFile().getAbsolutePath(), fileName); FileInputStream fis = new FileInputStream(file); ByteArrayOutputStream bos = new ByteArrayOutputStream(); int nextByteData; while ((nextByteData = fis.read()) != -1) &#123; bos.write(nextByteData); &#125; byte[] data = bos.toByteArray(); fis.close(); bos.close(); //将class二进制内容转换成Class对象 return defineClass(name, data, 0, data.length); &#125; catch (FileNotFoundException e) &#123; //2. 从jar包获取的.class文件中读取（已经存入缓存） if (this.clazzMap.containsKey(name)) &#123; byte[] data = this.clazzMap.get(name); return defineClass(name, data, 0, data.length); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return super.findClass(name); &#125; /** * 获取要加载的class文件名 * * @param name * @return */ private String getFileName(String name) &#123; int index = name.lastIndexOf(&apos;.&apos;); if (index == -1) &#123; return name + &quot;.class&quot;; &#125; else &#123; return name.substring(index + 1) + &quot;.class&quot;; &#125; &#125; /** * 读取jar包中的所有.class文件 */ private void readJarFile() &#123; List&lt;File&gt; list = scanDir(); for (File f : list) &#123; JarFile jar; try &#123; jar = new JarFile(f); readJAR(jar); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 扫描lib下面的所有jar包 * * @return */ private List&lt;File&gt; scanDir() &#123; List&lt;File&gt; list = new ArrayList&lt;&gt;(); File[] files = new File(Paths.get(this.myLibPath, &quot;lib&quot;).toFile().getAbsolutePath()).listFiles(); for (File f : files) &#123; if (f.isFile() &amp;&amp; f.getName().endsWith(&quot;.jar&quot;)) list.add(f); &#125; return list; &#125; /** * 读取一个jar包内的class文件，并存在当前加载器的map中 * * @param jar * @throws IOException */ private void readJAR(JarFile jar) throws IOException &#123; Enumeration&lt;JarEntry&gt; en = jar.entries(); while (en.hasMoreElements()) &#123; JarEntry je = en.nextElement(); String name = je.getName(); if (name.endsWith(&quot;.class&quot;)) &#123; String clazzName = name.replace(&quot;.class&quot;, &quot;&quot;).replaceAll(&quot;/&quot;, &quot;.&quot;); if (this.findLoadedClass(clazzName) != null) &#123; continue; &#125; InputStream is = jar.getInputStream(je); ByteArrayOutputStream bos = new ByteArrayOutputStream(); int nextByteData; while ((nextByteData = is.read()) != -1) &#123; bos.write(nextByteData); &#125; byte[] data = bos.toByteArray(); is.close(); bos.close(); this.clazzMap.put(clazzName, data);//暂时保存下来 &#125; &#125; &#125;&#125; 测试 123456789//测试加载路径为&quot;F:\testLib&quot;的类加载器 DiskClassLoader firstDiskClassLoader = new DiskClassLoader(&quot;F:\\testLib&quot;); Class clazz = firstDiskClassLoader .loadClass(&quot;com.wfw.Speak&quot;); if (clazz != null) &#123; Object object = clazz.newInstance(); Method setMethod = clazz.getDeclaredMethod(&quot;say&quot;); setMethod.invoke(object); &#125; 注意loadClass的类名需完整，包含包名。 ContextClassLoader——线程上下文类加载器ContextClassLoader其实只是一个概念。每个Thread都有一个相关联的ClassLoader，默认是AppClassLoader。并且子线程默认使用父线程的ClassLoader，除非子线程特别设置。测试：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public void testLoader() throws Exception &#123; //测试加载路径为&quot;F:\testLib&quot;的类加载器 DiskClassLoader firstDiskClassLoader = new DiskClassLoader(&quot;F:\\testLib&quot;); Class clazz = firstDiskClassLoader .loadClass(&quot;com.wfw.Speak&quot;); if (clazz != null) &#123; Object object = clazz.newInstance(); Method setMethod = clazz.getDeclaredMethod(&quot;say&quot;); setMethod.invoke(object); &#125; //测试加载路径为&quot;F:\testLib\ext&quot;的类加载器 DiskClassLoader extDistClassLoader = new DiskClassLoader(&quot;F:\\testLib\\ext&quot;); Class extClazz = extDistClassLoader.loadClass(&quot;com.wfw.Speak&quot;); if (extClazz != null) &#123; Object object = extClazz.newInstance(); Method setMethod = extClazz.getDeclaredMethod(&quot;say&quot;); setMethod.invoke(object); &#125; //测试Context ClassLoader 线程上下文类加载器 Thread thread = new Thread(() -&gt; &#123; //1. 测试子线程的classloader能否加载父线程中加载的class try &#123; Class subClazz = Thread.currentThread().getContextClassLoader() .loadClass(&quot;com.wfw.Speak&quot;); if (subClazz != null) &#123; Object object = subClazz.newInstance(); Method setMethod = subClazz.getDeclaredMethod(&quot;say&quot;); setMethod.invoke(object); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; //2. 修改子线程的context classloader try &#123; Thread.currentThread().setContextClassLoader(firstDiskClassLoader); Class subReloadedClazz = Thread.currentThread().getContextClassLoader() .loadClass(&quot;com.wfw.Speak&quot;); if (subReloadedClazz != null) &#123; Object object = subReloadedClazz.newInstance(); Method setMethod = subReloadedClazz.getDeclaredMethod(&quot;say&quot;); setMethod.invoke(object); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125;); thread.start(); &#125; 子线程的ContextClassLoader是AppClassLoader，AppClassLoader加载不了父线程当中已经加载的Speak.class，通过修改子线程的ContextClassLoader使得子线程成功加载Speak.class。 参考文章 一看你就懂，超详细java中的ClassLoader详解 自定义类加载器——从.class和.jar中读取 开始使用Java Lambda Expressions Launcher.java]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>classloader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot系列（四）——集成MyBatis]]></title>
    <url>%2F2018%2F03%2F20%2FSpringBoot%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E9%9B%86%E6%88%90MyBatis%2F</url>
    <content type="text"><![CDATA[Web服务免不了要跟数据库打交道，基于SpringBoot我们可以很方便地集成MyBatis来对数据库进行操作，本章讲述如何使用mybatis-generator插件生成ORM相关文件以及mybatis的使用。 新建数据库MyBatisDemo为了测试，我们建立两张表：User和Department，分别为用户表和部门表。创建脚本如下：1234567891011121314151617181920212223242526SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for Department-- ----------------------------DROP TABLE IF EXISTS `Department`;CREATE TABLE `Department` ( `id` int(8) unsigned NOT NULL AUTO_INCREMENT, `departmentName` varchar(255) NOT NULL, `departmentCulture` text, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=gbk;-- ------------------------------ Table structure for Users-- ----------------------------DROP TABLE IF EXISTS `Users`;CREATE TABLE `Users` ( `id` int(8) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(255) NOT NULL DEFAULT &apos;&apos;, `age` int(8) unsigned DEFAULT NULL, `sex` varchar(64) DEFAULT NULL, `address` varchar(255) DEFAULT &apos;&apos;, `departmentId` int(8) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=gbk; 生成entity，dao和mapper文件引入mybatis-generator插件的依赖jar包123456789101112131415161718&lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 添加配置文件mybatis-generator.xml在src/main/resources/config目录下新建mybatis-generator.xml文件：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;!--配置说明：http://blog.csdn.net/isea533/article/details/42102297 --&gt; &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;!--是否关闭时间标志true：是 false:否--&gt; &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt; &lt;!-- 是否去除自动生成的注释 true：是 false:否 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt; &lt;/commentGenerator&gt; &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码，可以提出到单独配置文件中 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://10.200.xx.xx:3306/MybatisDemo?characterEncoding=gbk&quot; userId=&quot;username&quot; password=&quot;password&quot;&gt; &lt;/jdbcConnection&gt; &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL和NUMERIC 类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt; &lt;/javaTypeResolver&gt; &lt;!-- 生成模型的包名和位置--&gt; &lt;javaModelGenerator targetPackage=&quot;com.wfw.entity&quot; targetProject=&quot;src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成映射文件的包名和位置--&gt; &lt;sqlMapGenerator targetPackage=&quot;com.wfw.mapper&quot; targetProject=&quot;src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成DAO(mapper接口)的包名和位置--&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.wfw.dao&quot; targetProject=&quot;src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;/javaClientGenerator&gt; &lt;!-- 要生成哪些表--&gt; &lt;!--tableName是数据库中的表名或视图名 domainObjectName是实体类名--&gt; &lt;table tableName=&quot;Users&quot; domainObjectName=&quot;Users&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt; &lt;!--如果设置为true,那么MBG会使用从数据库元数据获取的列名作为生成的实体对象的属性。 如果为false(默认值)，MGB将会尝试将返回的名称转换为驼峰形式。 在这两种情况下，可以通过元素显示指定，在这种情况下将会忽略这个（useActualColumnNames）属性。--&gt; &lt;property name=&quot;useActualColumnNames&quot; value=&quot;true&quot;/&gt; &lt;/table&gt; &lt;table tableName=&quot;Department&quot; domainObjectName=&quot;Department&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt; &lt;!--如果设置为true,那么MBG会使用从数据库元数据获取的列名作为生成的实体对象的属性。 如果为false(默认值)，MGB将会尝试将返回的名称转换为驼峰形式。 在这两种情况下，可以通过元素显示指定，在这种情况下将会忽略这个（useActualColumnNames）属性。--&gt; &lt;property name=&quot;useActualColumnNames&quot; value=&quot;true&quot;/&gt; &lt;!--解决字段类型为text等会默认产生XXXXWithBlobs的方法问题http://blog.csdn.net/maoliangfei2011/article/details/52231463--&gt; &lt;columnOverride column=&quot;departmentCulture&quot; javaType=&quot;java.lang.String&quot; jdbcType=&quot;VARCHAR&quot;/&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 详细配置及说明见参考文章1。 pom.xml中添加插件依赖及配置文件地址12345678910111213141516171819202122232425262728293031&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.45&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;Generate MyBatis Artifacts&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;generate&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;configurationFile&gt;src/main/resources/config/mybatis-generator.xml&lt;/configurationFile&gt; &lt;/configuration&gt;&lt;/plugin&gt; 注意： 需要添加插件版本，即&lt;version&gt;1.3.5&lt;/version&gt;，需要与插件引入的mybatis-generator-core依赖包的版本一致 插件需要依赖包mysql-connector-java和mybatis-generator-core configurationFile元素配置第一步创建的配置文件地址。generate可以看到在src/com/wfw目录下产生三个目录：dao，entity和mapper，不直接把生成的文件放到java目录下的原因：如果修改表结构需要重新生成文件，则会覆盖已经修改的文件，因此单独生成到src/com/wfw目录下，然后拷贝到对应目录即可。则我们现在的目录结构为： 依赖注入application.properties中配置数据库及mybatis的mapper目录12345678910# mysql数据库相关配置spring.datasource.url=jdbc:mysql://10.200.xx.xx:3306/MybatisDemospring.datasource.username=usernamespring.datasource.password=passwordspring.datasource.driver-class-name=com.mysql.jdbc.Driver# mybatis相关配置mybatis.mapperLocations=classpath:com/wfw/mapper/*.xml# 控制台输出sql日志信息mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl 注意：如果不配置mysql数据库相关，则SpringBoot启动失败，如果不进行mybatis的mapper目录相关配置，则会出现Invalid bound statement (not found)的异常 配置pom.xml的build元素build元素中添加123456789&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt;&lt;/resources&gt; 这是因为我们的mapper.xml文件放在java/com/wfw/mapper包下，而默认build的时候.xml文件没有被build到target/classes/com/wfw/mapper目录下，我们上一步中配置的mybatis.mapperLocations=classpath:com/wfw/mapper/*.xml找不到相关的mapper.xml文件，也会出现Invalid bound statement (not found)的异常。 数据访问层接口添加注解 在生成的UsersMapper,DepartmentMapper接口添加注解@Mapper和@Component。为了测试，UsersMapper接口中添加两个接口方法，这个两个接口方法需要我们在UsersMapper.xml文件中通过实现 1234List&lt;UserDTO&gt; listUsers(@Param(value = &quot;from&quot;) int from, @Param(value = &quot;size&quot;) int size);int countUsers(); 注意：@Param指定该变量在mapper.xml文件中被引用的名称，引用方式为#{value} 在UsersMapper.xml文件中添加其实现 123456789&lt;resultMap id=&quot;UserDtoResultMap&quot; type=&quot;com.wfw.dto.user.UserDTO&quot;&gt;&lt;/resultMap&gt;&lt;select id=&quot;listUsers&quot; resultMap=&quot;UserDtoResultMap&quot;&gt; select Users.`name` as userName, Department.departmentName as department from Users inner join Department on Department.id = Users.departmentId limit #&#123;from&#125;, #&#123;size&#125;;&lt;/select&gt;&lt;select id=&quot;countUsers&quot; resultType=&quot;java.lang.Integer&quot;&gt; select count(*) from Users;&lt;/select&gt; 需要注意resultMap和resultType的区别。 Service层接口定义及实现 定义Service层接口 1234public interface UserService &#123; List&lt;UserDTO&gt; listUsers(int pageIndex, int pageSize); int countUsers();&#125; 实现Service层接口，需要添加@Service注解，从而能够在Controller层使用时自动注入。在Service实现时，我们展示数据访问接口的自动注入（使用@Autowired注解） 12345678910111213141516@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UsersMapper usersMapper; @Override public List&lt;UserDTO&gt; listUsers(int pageIndex, int pageSize) &#123; int from = (pageIndex - 1) * pageSize; return this.usersMapper.listUsers(from, pageSize); &#125; @Override public int countUsers() &#123; return this.usersMapper.countUsers(); &#125;&#125; Controller层注入Service接口在UserController层中12345678910111213@Autowiredprivate UserService userService;@RequestMapping(path = &quot;/listUsers&quot;, method = RequestMethod.POST)@ApiOperation(value = &quot;获取用户信息列表&quot;)ListUsersResponseVO listUsers(@RequestBody ListUsersRequestVO request)&#123; ListUsersResponseVO response = new ListUsersResponseVO(); response.setData(this.userService.listUsers(request.getPageIndex(), request.getPageSize())); response.setTotal(this.userService.countUsers()); response.setResult(true); response.setMessage(&quot;OK&quot;); return response;&#125; 参考文章 MyBatis-generator 详解 Invalid bound statement (not found)错误的可能原因 mybatis中文参考文档]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpSpringBoot系列（三）——日志记录]]></title>
    <url>%2F2018%2F03%2F16%2FSpringBoot%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[日志在项目开发过程中及服务部署后对于解决问题起着至关重要的作用，本章介绍如何在SpringBoot中使用logback将日志记录到文件或RabbitMQ中。 引入logback在pom.xml文件中，添加包引用：123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt; &lt;artifactId&gt;spring-amqp&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt; &lt;artifactId&gt;spring-rabbit&lt;/artifactId&gt;&lt;/dependency&gt; 使用默认版本。 添加配置文件logback.xml 在resources/config目录下添加日志配置文件logback.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;false&quot;&gt; &lt;contextName&gt;logback-SpringBootDemoSingle&lt;/contextName&gt; &lt;property name=&quot;log.file&quot; value=&quot;logback.log&quot; /&gt; &lt;property name=&quot;FilePath&quot; value=&quot;/data1/logs/dev/SpringBootDemoSingle&quot; /&gt; &lt;!--输出到控制台--&gt; &lt;appender name=&quot;Console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--输出到文件并且切分日志文件--&gt; &lt;appender name=&quot;ErrorFile&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;param name=&quot;encoding&quot; value=&quot;UTF-8&quot; /&gt; &lt;param name=&quot;file&quot; value=&quot;$&#123;FilePath&#125;/fileERROR/$&#123;log.file&#125;&quot; /&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;$&#123;FilePath&#125;/fileERROR/logback.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name=&quot;InfoFile&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;param name=&quot;encoding&quot; value=&quot;UTF-8&quot; /&gt; &lt;param name=&quot;file&quot; value=&quot;$&#123;FilePath&#125;/fileINFO/$&#123;log.file&#125;&quot; /&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;$&#123;FilePath&#125;/fileINFO/logback.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name=&quot;amqp&quot; class=&quot;org.springframework.amqp.rabbit.logback.AmqpAppender&quot;&gt; &lt;layout&gt; &lt;pattern&gt; &#123; &quot;time&quot;: &quot;%date&quot;, &quot;thread&quot;: &quot;%thread&quot;, &quot;level&quot;: &quot;%level&quot;, &quot;class&quot;: &quot;%logger&quot;, &quot;message&quot;: &quot;%message&quot;, &quot;system&quot;: &quot;SpringBootDemoSingle&quot; &#125; &lt;/pattern&gt; &lt;/layout&gt; &lt;host&gt;10.200.xx.xx&lt;/host&gt; &lt;port&gt;5672&lt;/port&gt; &lt;virtualHost&gt;/&lt;/virtualHost&gt; &lt;username&gt;username&lt;/username&gt; &lt;password&gt;password&lt;/password&gt; &lt;exchangeType&gt;topic&lt;/exchangeType&gt; &lt;exchangeName&gt;rd6.log&lt;/exchangeName&gt; &lt;applicationId&gt;SpringBootDemoSingle&lt;/applicationId&gt; &lt;routingKeyPattern&gt;routeKey&lt;/routingKeyPattern&gt; &lt;contentType&gt;application/json&lt;/contentType&gt; &lt;maxSenderRetries&gt;2&lt;/maxSenderRetries&gt; &lt;declareExchange&gt;true&lt;/declareExchange&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/appender&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;InfoFile&quot;/&gt; &lt;appender-ref ref=&quot;amqp&quot;/&gt; &lt;/root&gt; &lt;root level=&quot;error&quot;&gt; &lt;appender-ref ref=&quot;ErrorFile&quot; /&gt; &lt;/root&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;Console&quot; /&gt; &lt;/root&gt;&lt;/configuration&gt; 注意：输出到控制台的等级控制要放到最后 该配置文件将日志输出到文件和RabbitMQ中。具体配置见参考文章3。 application.properties中配置logback的配置文件目录 12# 日志配置文件logging.config=classpath:config/logback.xml 记录日志在代码中记录日志1LoggerFactory.getLogger(LogInterceptor.class).error(&quot;error test&quot;); 使用拦截器记录每个接口的耗时 定义日志记录拦截器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class LogInterceptor implements HandlerInterceptor&#123; private Logger logger = LoggerFactory.getLogger(LogInterceptor.class); /** * controller 执行之前调用 * @param request * @param response * @param handler * @return * @throws Exception */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; long startTime = System.currentTimeMillis(); //记录起始时间 request.setAttribute(&quot;startTime&quot;, startTime); logger.error(&quot;error test&quot;); return true; &#125; /** * controller 执行之后，且页面渲染之前调用 * @param request * @param response * @param handler * @param modelAndView * @throws Exception */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception &#123; // You can add attributes in the modelAndView &#125; /** * 页面渲染之后调用，一般用于资源清理操作 * @param request * @param response * @param handler * @param ex * @throws Exception */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception &#123; long startTime = (long)request.getAttribute(&quot;startTime&quot;); //获取起始时间 long endTime = System.currentTimeMillis(); long timeTaken = endTime - startTime; String requestUrl = request.getRequestURL().toString(); logger.info(&quot;调用接口：&quot; + requestUrl + &quot;，耗时&quot; + timeTaken); &#125;&#125; 在WebMvcConfig.java中注册拦截器 上一章我们在解决json序列化的时候已经override过configureMessageConverters个方法，拦截器的注册是在addInterceptors方法中： 123456789101112@Override public void addInterceptors(InterceptorRegistry registry) &#123; //LogInterceptor拦截器应用于所有URLs registry.addInterceptor(new LogInterceptor()); //登录拦截器，不拦截登录接口和swagger静态资源 registry.addInterceptor(new LoginInterceptor()) .excludePathPatterns(&quot;/user/login&quot;, &quot;/swagger-resources/**&quot;, &quot;/swagger-ui.html&quot;, &quot;/v2/api-docs&quot;); //addPathPatterns和excludePathPatterns分别用于指定路由和排除路由 &#125; 注意：此外为了测试，写了一个用户登录的拦截器。再进行一下接口的调用测试，你会发现每个接口的耗时都被记录到了日志中。 参考文章 Spring中拦截器和过滤器区别 SpringBoot中拦截器的使用 默认日志logback配置解析]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot系列（二）——集成Swagger]]></title>
    <url>%2F2018%2F03%2F15%2FSpringBoot%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E9%9B%86%E6%88%90Swagger%2F</url>
    <content type="text"><![CDATA[现在开发项目很多都采用前后端分离的模式，后端提供Restful接口，前端进行对接。提供详细的接口说明问题可以简化前后端对接步骤，提高工作效率，而Swagger为我们提供了自动生成接口说明文档的功能，且提供了可视化ui，非常方便。本文介绍如何在SpringBoot中集成Swagger及相关的优化配置。 引入Swagger pom.xml文件添加第三方jar包 12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt; 添加配置文件在包config下，新建文件SwaggerConfig.java，内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142@Configuration@EnableSwagger2public class SwaggerConfig &#123; @Bean public Docket restfulApi()&#123; return new Docket(DocumentationType.SWAGGER_2) .genericModelSubstitutes(DeferredResult.class) .useDefaultResponseMessages(true) .forCodeGeneration(true) .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.wfw.controller&quot;)) .build().globalOperationParameters(GetHeader()) .apiInfo(initApiInfo()); &#125; private List&lt;Parameter&gt; GetHeader() &#123; ParameterBuilder token = new ParameterBuilder(); List&lt;Parameter&gt; parameters = new ArrayList&lt;&gt;(); token.name(&quot;X-Request-Token&quot;).description(&quot;Token&quot;).modelRef(new ModelRef(&quot;string&quot;)).parameterType(&quot;header&quot;).required(false).build(); parameters.add(token.build()); return parameters; &#125; private ApiInfo initApiInfo() &#123; ApiInfo apiInfo = new ApiInfoBuilder() .title(&quot;SpringBoot Demo后端WebAPI&quot;) .description(initContextInfo()) .version(&quot;1.0&quot;) .build(); return apiInfo; &#125; private String initContextInfo() &#123; StringBuffer sb = new StringBuffer(); sb.append(&quot;REST API 设计在细节上有很多自己独特的需要注意的技巧，并且对开发人员在构架设计能力上比传统 API 有着更高的要求。&quot;).append(&quot;&lt;br/&gt;&quot;) .append(&quot;以下是本项目的API文档&quot;); return sb.toString(); &#125;&#125; @Configuration表明该类为IOC容器的配置类。且该配置类为Swagger中每个接口的header提供了一个名为X-Request-Token的参数，便于传递token参数。 使用我们介绍常用的注解，详细使用说明见参考文章1 在Controller上使用@Api注释该Controller的相关信息，例如： 123@Api(value = &quot;GreetingController&quot;, description = &quot;GreetingController描述&quot;)public class GreetingController extends BaseController &#123;&#125; 在接口方法上使用@ApiOperation注释该接口的说明信息，例如： 123@ApiOperation(value = &quot;使用Get方法greeting&quot;) public GreetingResponseVO greetingByGet(@RequestParam(value=&quot;name&quot;, defaultValue=&quot;World&quot;) String name)&#123; &#125; 使用@ApiModel和@ApiModelProperty对数据模型结构进行说明，例如： 1234567891011121314151617181920212223@ApiModel(value = &quot;GreetingResponseVO&quot;, description = &quot;Greeting响应&quot;)public class GreetingResponseVO extends BaseResponseVO &#123; @ApiModelProperty(value = &quot;id&quot;) private long id; @ApiModelProperty(value = &quot;内容&quot;) private String content; public long getId() &#123; return id; &#125; public void setId(long id) &#123; this.id = id; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125;&#125; 启动服务，浏览器中：http://localhost:8080/swagger-ui.html 解决Swagger参数无法传输换行字符串的问题如果直接拷贝了一长串换行文本传入接口参数中，会提示如下错误： org.codehaus.jackson.JsonParseException: Illegal unquoted character ((CTRL-CHAR, code 9)): has to be escaped using backslash to be included in string valueat [Source: java.io.StringReader@10cfc2e3; line: 1, column: 2461]这是因为传输的json参数中含有转义字符，而框架使用jackson未对其进行转换。 解决方法： pom.xml引入第三方jar包 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.15&lt;/version&gt;&lt;/dependency&gt; 包config中添加配置类WebMvcConfig，内容如下： 12345678910111213141516@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; FastJsonHttpMessageConverter fastConverter = new FastJsonHttpMessageConverter(); FastJsonConfig fastJsonConfig = new FastJsonConfig(); fastJsonConfig.setSerializerFeatures( SerializerFeature.PrettyFormat ); fastConverter.setFastJsonConfig(fastJsonConfig); converters.add(fastConverter); &#125;&#125; 参考文章 swagger常用注解说明 springboot接收JSON时发生转义字符绑定对象失败]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>微服务</tag>
        <tag>Swagger</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot系列（一）——搭建SpringBoot框架]]></title>
    <url>%2F2018%2F03%2F12%2FSpringBoot%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%90%AD%E5%BB%BASpringBoot%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[SpringBoot可以使你快速构建基于Spring的应用服务，它集成了Spring平台和第三方库，功能可插拔，将很多配置做了默认处理（习惯优于配置），只需要很少的Spring配置。本文对SpringBoot做简要介绍，并基于SpringBoot快速构建Web服务。 一、SpringBoot特点 快速构建独立运行的Spring服务 内嵌tomcat，无需部署war包 提供spring-boot-starter-*的POMs简化maven配置 自动配置Spring 二、快速搭建Web服务环境配置：开发工具为Intellij IDEA，Java8，Maven3.5 创建项目File &gt;&gt; New &gt;&gt; Project &gt;&gt; Spring Initializer选择next，注意Type选择Maven Project(Generate a maven based project archive)选择next，SpringBoot版本选择2.0.0，勾选Web然后next，Finish即完成构建。 可以看到项目是一个空框架，基本没有代码，主要包含以下内容： SpringBootDemoSingleApplication.java：一个带有main方法的类，启动应用程序的入口 SpringBootDemoSingleApplicationTests.java：一个空的Junit测试类，它加载了一个使用Spring Boot字典配置功能的Spring应用程序上下文 application.properties：SpringBoot的配置文件，如果需要修改SpringBoot的默认配置，则需要在此文件中进行修改 pom.xml：maven配置文件，用于添加引用包 配置pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.wfw&lt;/groupId&gt; &lt;artifactId&gt;springbootdemosingle&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;SpringBootDemoSingle&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;SpringBoot-demo&lt;/finalName&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/**&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 自己稍微做了一些修改，构建jar包过程中忽略单元测试。 parent配置 123456 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; 即SpringBoot父级依赖，它是一个特殊的starter，用来指定其他starter的Maven默认依赖版本。可以去本地maven仓库的子目录repository\org\springframework\boot\spring-boot-dependencies\2.0.0.RELEASE下查看spring-boot-dependencies-2.0.0.RELEASE.pom文件，该POMs文件使用properties和dependencyManagement控制第三方库的默认引用版本[^参考文章9]。如果不想使用默认版本，可以在自己项目的POMs文件中指定相应jar包的版本号 spring-boot-starter-xxx起步依赖SpringBoot提供了很多”开箱即用“的依赖模块，都是以spring-boot-starter-xxx作为命名的。起步依赖本质上是一个Maven项目对象模型（Project Object Model，POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。很多起步依赖的命名都暗示了它们提供的某种或者某类功能。 SpringBoot Maven插件 1234&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&lt;/plugin&gt; 把项目打包成一个可执行的超级JAR（uber-JAR）,包括把应用程序的所有依赖打入JAR文件内，并为JAR添加一个描述文件，其中的内容能让你用java -jar来运行应用程序。 构建Restful风格接口 创建如下结构的目录各目录结构说明： config: 用于写配置 controller：Controller层 dao：数据访问层相关接口定义 dto：数据模型 entity：ORM映射模型 filter：过滤器 mapper：ORM映射文件 service：业务逻辑层接口定义及实现 vo：数据展示模型 创建名为controller的package，添加GreetingController 12345678910111213141516171819202122232425@RestController@RequestMapping(path = &quot;/greeting&quot;)@Api(value = &quot;GreetingController&quot;, description = &quot;GreetingController描述&quot;)public class GreetingController extends BaseController &#123; private static final String template = &quot;Hello, %s!&quot;; private final AtomicLong counter = new AtomicLong(); @RequestMapping(path=&quot;greetingByGet&quot;, method= RequestMethod.GET) @ApiOperation(value = &quot;使用Get方法greeting&quot;) public GreetingResponseVO greetingByGet(@RequestParam(value=&quot;name&quot;, defaultValue=&quot;World&quot;) String name)&#123; GreetingResponseVO response = new GreetingResponseVO(); response.setId(counter.incrementAndGet()); response.setContent(String.format(template, name)); return response; &#125; @RequestMapping(path = &quot;greetingByPost&quot;, method = RequestMethod.POST) @ApiOperation(value = &quot;使用Post方法greeting&quot;) public GreetingResponseVO greetingByPost(@RequestBody GreetingRequestVO request)&#123; GreetingResponseVO response = new GreetingResponseVO(); response.setId(counter.incrementAndGet()); response.setContent(String.format(template, request.getName())); return response; &#125;&#125; 相关注解说明： @RequestMapping：指定http的路由 @RestController：指定该Controller下所有的Post方法响应以json格式返回，它是@Controller和@ResponseBody的组合 @RequestBody：以json格式接收http参数 @RequestParam：从get方法的url中获取参数 @Api和@ApiOperation：Swagger的相关注解 运行使用SpringBoot内置的tomcat运行jar包的方式，通过扫描SpringBootDemoSingleApplication中的main方法为入口启动程序。 1234567@SpringBootApplicationpublic class SpringBootDemoSingleApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootDemoSingleApplication.class, args); &#125;&#125; @SpringBootApplication非常方便地提供了以下注解： @Configuration：将SpringBootDemoSingleApplication标记为应用程序上下文的bean定义类 @EnableAutoConfiguration：告诉SpringBoot在启动时根据classpath配置，其他beans和各种属性配置添加beans @EnableWebMvc：SpringBoot在classpath中检测到spring-webmvc时自动添加了@EnableWebMvc，它将程序标记为Web服务并执行关键步骤，比如设置DispatcherServlet @ComponentScan：告诉Spring寻找其他组件，配置和hello中的服务，使其寻找Controller。将标注了元信息Annotation的bean定义类批量采集到Spring的IOC容器中，如果不指定其basePackages属性，则Spring框架默认会从声明@ComponentScan所在类的package进行扫描，即com.wfw 使用maven编译：mvnw clean package执行jar包：java -jar target/SpringBoot-demo.jar 或者直接在Intellij IEEA中启动 配置文件解析搭建好SpringBoot后，会自动生成一个全局的配置文件application.properties。也可以自定义配置文件，例如我们在resources目录下新建目录config用于存放我们的自定义配置文件。可以定义一个配置类，用于IoC容器注册和收集我们的配置项。 自定义配置及引用 创建自定义配置文件假设我们自定义的配置文件config1.properties和config2.properties内容分别为： 1234# config1.properties内容config1.username=killer9527# config2.properties内容config2.password=123456 定义配置类然后我们可以在包config中定义一个配置类ConfigurationConfig.java，内容如下： 1234567@Configuration@PropertySources(&#123; @PropertySource(&quot;classpath:config/config1.properties&quot;), @PropertySource(&quot;classpath:config/config2.properties&quot;)&#125;)public class ConfigurationConfig &#123;&#125; 引用配置项比如在Controller中使用，则可以定义一变量 12@Autowiredprivate Environment env; 使用12env.getProperty(&quot;config1.username&quot;)env.getProperty(&quot;config2.password&quot;) 需要注意的是 Properties added in this way have lower priority than any added byusing the default locations (such as application.properties), system properties, environment variables, or the command line 配置随机值配置文件中${random} 可以用来生成各种不同类型的随机值，例如：123456my.secret=$&#123;random.value&#125;my.number=$&#123;random.int&#125;my.bignumber=$&#123;random.long&#125;my.uuid=$&#123;random.uuid&#125;my.number.less.than.ten=$&#123;random.int(10)&#125;my.number.in.range=$&#123;random.int[1024,65536]&#125; 命令行参数配置比如：java -jar xx.jar --server.port=9090。命令行中连续的两个减号–就是对application.properties中的属性值进行赋值的标识。 Profile-多环境配置开发过程中，我们针对不同的开发环境相应的会有不同的配置，如果各种开发环境都使用同一个配置文件，那么我们每次发布时，都需要修改相应的配置，很繁琐。SpringBoot的profile针对这个问题专门实现了多环境配置选择配置文件的功能，多环境配置文件名需要满足application-{profile}.properties的格式，其中{profile}对应你的环境标识。具体实现步骤如下： 创建各种开发环境配置文件我们分三个环境：develop，release和online，分别对应的配置文件为application-develop.properties，application-release.properties和application-online.properties，为了测试，内容分别为： 123456789# application-develop.properties内容server.port=8080profile.property=develop# application-release.properties内容server.port=8081profile.property=release# application-online.properties内容server.port=8082profile.property=online 在application.properties中通过配置spring.profiles.active变量选择配置文件 12# application.properties内容spring.profiles.active=online 也可以通过命令行参数配置spring.profiles.active变量来实现配置的选择 你可以启动SpringBoot，看看需要用哪个端口访问。 SpringBoot核心注解说明@Configuration它用于标记JavaConfig形式的Spring Ioc容器的配置类。配置类与基于XML配置功能相对应。 表达形式 基于XML配置的方式： 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot; default-lazy-init=&quot;true&quot;&gt; &lt;!--bean定义--&gt;&lt;/beans&gt; 而基于JavaConfig的配置类配置方式： 1234@Configurationpublic class MockConfiguration&#123; //bean定义&#125; 注册bean定义方式 基于XML配置的方式： 123&lt;bean id=&quot;mockService&quot; class=&quot;..MockServiceImpl&quot;&gt; ...&lt;/bean&gt; 而基于JavaConfig的配置类配置方式： 1234567@Configurationpublic class MockConfiguration&#123; @Bean public MockService mockService()&#123; return new MockServiceImpl(); &#125;&#125; 任何一个标注了@Bean的方法，其返回值将作为一个bean定义注册到Spring的IoC容器，方法名将默认成该bean定义的id。 依赖注入实现方式 基于XML配置的方式： 1234&lt;bean id=&quot;mockService&quot; class=&quot;..MockServiceImpl&quot;&gt; &lt;propery name =&quot;dependencyService&quot; ref=&quot;dependencyService&quot; /&gt;&lt;/bean&gt;&lt;bean id=&quot;dependencyService&quot; class=&quot;DependencyServiceImpl&quot;&gt;&lt;/bean&gt; 而基于JavaConfig的配置类配置方式： 123456789101112@Configurationpublic class MockConfiguration&#123; @Bean public MockService mockService()&#123; return new MockServiceImpl(dependencyService()); &#125; @Bean public DependencyService dependencyService()&#123; return new DependencyServiceImpl(); &#125;&#125; 如果一个bean的定义依赖其他bean,则直接调用对应的JavaConfig类中依赖bean的创建方法就可以了。 @ComponentScan@ComponentScan的功能其实就是自动扫描并加载符合条件的组件（比如@Component和@Repository等）或者bean定义，最终将这些bean定义加载到IoC容器中。我们可以通过basePackages等属性来细粒度的定制@ComponentScan自动扫描的范围，如果不指定，则默认Spring框架实现会从声明@ComponentScan所在类的package进行扫描。 SpringBoot的启动类最好是放在root package下，因为默认不指定basePackages。 @EnableAutoConfiguration借助@Import的支持，将所有符合自动配置条件的bean定义加载到IoC容器。 个人理解，@Configuration负责bean定义，@ComponentScan负责扫描，@EnableAutoConfiguration负责实现将bean定义加载到IoC容器。 参考文章 Spring Boot干货系列总纲 程序猿DD-Spring Boot系列 纯洁的微笑-Sping Boot系列文章 CSDN-小单博客Spring Boot专栏 梁桂钊的博客-Spring Boot 揭秘与实战 林祥纤博客系列-从零开始学Spring Boot 杜琪关于Spring Boot的博客集合 泥瓦匠BYSocket的Spring Boot系列 Maven中dependencies与dependencyManagement的区别 application.properties常见配置属性 关于XML文档的xmlns、xmlns:xsi和xsi:schemaLocation]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins+Github持续集成]]></title>
    <url>%2F2018%2F02%2F28%2FJenkins-Github%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[Github作为代码仓储可以控制代码的版本迭代，而Jenkins是一种持续集成工具，可用于代码的编译和发布，当push代码到GitHub仓库之后，我们希望能够自动触发Jenkins从GitHub拉取代码，然后进行编译和发布。 Jenkins安装 安装java环境yum install java 下载Jenkins：wget http://mirrors.jenkins.io/war-stable/latest/jenkins.war并修改权限chmod +x jenkins.war 编写启动脚本jenkins_start.sh 12345678910111213#!/bin/bashNAME=&quot;jenkins.war&quot;echo $NAMEID=`ps -ef | grep &quot;$NAME&quot; | grep -v &quot;grep&quot; | awk &apos;&#123;print $2&#125;&apos;`echo $IDecho &quot;---------------&quot;for id in $IDdokill -9 $idecho &quot;killed $id&quot;doneecho &quot;---------------&quot;nohup java -jar jenkins.war --httpPort=8008 &amp; 添加启动权限：chmod +x jenkins_start.sh 开启8008端口 12firewall-cmd --zone=public --add-port=8008/tcp --permanentfirewall-cmd --reload 设置成开机启动（未成功。。） 修改/etc/rc.d/rc.local文件，添加启动脚本的目录 chmod +x /etc/rc.d/rc.local 集成GitHub安装GitHub插件系统管理-&gt;管理插件-&gt;可选插件，过滤条件“github plugin”，选中“github plugin”，直接安装。可能已经安装过了 配置GitHub插件系统管理-&gt;系统设置-&gt;GitHub-&gt;Add GitHub Server Github中生成access tokenSettings &gt;&gt; Developer settings &gt;&gt; Personal access tokens需要勾选的scopes：repo和admin:repo_hook 添加Credentialskind选择Secret text，并填写Secret 使用Test connection测试 创建一个自由风格任务 创建新任务，选择自由风格的任务 选择GitHub project，填写Project url 源码管理，选择Git，Add Credentials（使用GitHub的用户名和密码），选择githubweb源码浏览器，并填写项目url 构建触发器勾选GitHub hook trigger for GITScm polling 使用shell将blog自动发布到指定目录（只能在Jenkins所在服务器）构建 &gt;&gt; 增加构建步骤 &gt;&gt; Execute shell123456echo $JENKINS_HOMEcd $JENKINS_HOMEcd workspacelscp -rf hexo-blog /data/nginx_githubecho &quot;deploy success!&quot; 配置GitHub仓库的Webhooks进入要监控的仓库，Settings &gt;&gt; Webhooks，Add webhook 完成以上步骤之后，如果对被监控的仓库有push操作，则会触发Jenkins从git上拉取代码并进行build。则程序会发布到指定目录/data/nginx_github，然后就可以通过配置nginx访问了。 Maven编译并远程发布环境配置 Jenkins服务器和目标计算机上配置SSH（root账号登录）id_rsa.pub里面的内容是需要附加到你要远程连接的服务器上的用户的家目录下的.ssh目录下的authorized_keys的。在认证时，客户端会使用私钥对服务器发来的一些数据进行加密。而服务器端使用公钥钥解密，如果成功就直接认证通过。 生成ssh的公钥和私钥：ssh-keygen -t rsa，会提示输入：密钥存放位置（直接回车，默认在/root/.ssh/目录）、密码短语、重复密码短语。完成后在/root/.ssh/目录下生成了2个文件：id_rsa为私钥，id_rsa.pub为公钥 导入公钥：cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 设置正确的文件和文件夹权限 1chmod -R 0600 ~/.ssh 修改SSH配置文件，支持使用证书登录：vim /etc/ssh/sshd_config，修改对应项的配置 1234RSAAuthentication yesStrictModes noPubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keys 重启ssh服务：systemctl restart sshd.service 测试：ssh localhost 将Jenkins服务器上的公钥内容添加到目标计算机的authorized_keys中。 安装Publish Over SSH插件并配置 系统管理 &gt;&gt; 管理插件 &gt;&gt; 可选插件，直接安装 系统管理 &gt;&gt; 系统配置，找到Publish over SSH的配置 Jenkins SSH Key配置 Passphrase：生成密钥时的密码 Path to key：ssh的私钥路径，一般为/root/.ssh/id_rsa Key：私钥内容（如果指定了私钥路径，则可为空） SSH Servers配置 Name：要部署的目标计算机名称（可任意指定） Hostname：目标计算机地址 Username：目标计算机的登录用户名 Remote Directory：要发布到的目录目的是让Jenkins所在服务器和程序要部署的服务器之间可以通过ssh进行免密码访问。 安装Maven Integration插件和配置只有安装了该插件，新建任务的时候才可以选择构建一个maven项目系统管理 &gt;&gt; 全局工具配置，安装和配置jdk和maven 新建项目选择构建maven项目 源码管理，选择Git，填写Repository URL，选择Credentials，指定Branch 构建触发器，选择GitHub hook trigger for GITScm polling Build，Root POM：SpringBootDemoSingle/pom.xml Post Steps，选择Run only if build succeeds，Add post-build step选择Send files or execute commands over SSH，配置如图 start.sh的内容为： 123456789101112131415161718#!/bin/shNAME=SprintbootDemoecho $NAMEID=`ps -ef | grep &quot;$NAME&quot; | grep -v &quot;grep&quot; | awk &apos;&#123;print $2&#125;&apos;`echo $IDecho &quot;---------------&quot;for id in $IDdokill -9 $idecho &quot;killed $id&quot;doneecho &quot;---------------&quot;if [ -f &quot;SpringBoot-demo-start.jar&quot; ]; thenrm -f SpringBoot-demo-start.jarmv SpringBoot-demo.jar SpringBoot-demo-start.jarfichmod +x SpringBoot-demo-start.jarnohup java -jar SpringBoot-demo-start.jar --name=$NAME --server.port=8088 &amp; 验证：curl http://localhost:8080/swagger-ui.html 管理节点当Jenkins需要处理多个任务时，进行分布式处理很有必要。比如可以部署一个专用于发布java项目的节点，一个专用于发布.net项目的节点或者一个专用于发布node项目的节点。 创建节点系统管理 &gt;&gt; 管理节点 &gt;&gt; 新建节点，指定节点名称node1，选中固定代理，OK。 节点配置，如下图 结果如图 使用在创建job时，在general中通过标签选择使用的节点，如图 参考文章 Github Plugin Jenkins+Github持续集成 Jenkins+GIT+Maven+Shell 实现项目一键发布 jenkins gulp 持续集成环境搭建 Jenkins+Git+Maven+Shell+Tomcat持续集成经典教程 Jenkins使用简易教程 CentOS7 SSH使用证书登录 linux下ssh和Xshell通过密钥登陆总结 使用Jenkins实现自动构建Maven项目]]></content>
      <categories>
        <category>CI</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx安装与配置]]></title>
    <url>%2F2018%2F02%2F26%2FNginx%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Nginx是一个Http服务器，与传统的服务器不同，Nginx不依赖多线程处理请求，它采用高扩展性的事件驱动型的架构，性能好，稳定，配置简单且资源消耗小。本文介绍nginx的安装与配置。 安装安装环境：CentOS7 安装Nginx仓库 1sudo yum install epel-release 安装Nginx 1sudo yum install nginx 启动Nginx 12systemctl start nginxsystemctl status nginx 注意nginx默认使用80端口启动，如果启动失败，可以查看80端口是否被占用，如果占用，则杀死进程 123netstat -lnp | grep 80ps pidkill pid 其中pid为进程id 如果有防火墙，需要运行如下命令运行http和https访问 123sudo firewall-cmd --permanent --zone=public --add-service=http sudo firewall-cmd --permanent --zone=public --add-service=httpssudo firewall-cmd --reload 验证 1http://server_domain_name_or_IP/ 配置成开机启动 1sudo systemctl enable nginx 重新加载配置 1nginx -s reload Nginx介绍Nginx有一个主进程（master process）和很多工作进程（worker processes）。主进程用来读取配置并维护工作进程，工作进程处理请求。 Nginx配置介绍配置文件的结构及指令介绍Nginx有各种模块组成，而模块则由配置文件中的各种指令（directives）控制。Directives又分为simple directives和block directives。simple directive结构如下：1name parameter; block directive结构与simple directive类似，不过不是以;结尾，而是以{}结尾，例如：123location /documents/ &#123; [ configuration C ]&#125; 如果{}中有其他directives，我们称之为context。#后面为注释 location——根据request URI设置配置 1234语法: location [ = | ~ | ~* | ^~ ] uri &#123; ... &#125;location @name &#123; ... &#125;默认值: —Context: server, location ~*（大小写不敏感 ）或~（大小写敏感）——正则匹配 ^~或无修饰——前缀匹配 =——精确匹配匹配过程：首先进行精确匹配，匹配到此停止；然后使用uri进行前缀匹配，匹配出最长的的location，并记录，假设为location_prefix_longest，如果前缀匹配用^~修饰，则匹配到此停止；再然后进行正则匹配检查，假设匹配到的第一个location为location_reg_first，则使用location_reg_first中的配置，如果没有匹配到，则使用location_prefix_longest中的配置。举例说明： 123456789101112131415location = / &#123; [ configuration A ]&#125;location / &#123; [ configuration B ]&#125;location /documents/ &#123; [ configuration C ]&#125;location ^~ /images/ &#123; [ configuration D ]&#125;location ~* \.(gif|jpg|jpeg)$ &#123; [ configuration E ]&#125; /请求匹配configuration A，/index.html匹配configuration B，在/documents/document.html匹配configuration C，/images/1.gif匹配configuration D，/documents/1.jpg匹配configuration E。@定义了一个命名location，它用于请求重定向。不能嵌套且不能包含嵌套locations。 默认服务器根目录默认服务器根目录为/usr/share/nginx/html，我们在安装nginx步骤进行验证时看到的页面所相关的文件就放置在该目录下，默认服务的配置文件为/etc/nginx/nginx.conf.default Nginx全局配置文件Nginx的全局配置文件为/etc/nginx/nginx.conf，注意它的内容中有一条包含配置include /etc/nginx/conf.d/*.conf;，表明它将/etc/nginx/conf.d目录下所有以.conf结尾的配置文件包含进来，实现配置的扩展。 在/etc/nginx/conf.d/中添加配置 避免使用if指令 if指令是为rewrite模块设计的（location模块中只有rewrite或return），其他应用不推荐使用。例如： 123456if ($request_method = POST ) &#123; return 405;&#125;if ($args ~ post=140)&#123; rewrite ^ http://example.com/ permanent;&#125; 使用try_files判断文件是否存在。 访问静态内容 创建目录/data/nginx_www，并添加index.html文件，创建/data/nginx_image，并添加图片songhuiqiao.jpeg cd /etc/nginx/conf.d并创建配置文件static_content.conf 12345678910111213 server &#123; listen 8001; server_name static_content; root /usr/share/nginx/html; location / &#123; root /data/nginx_www; &#125; location /nginx_images/ &#123; root /data; &#125;&#125; 重新加载nginx配置nginx -s reload 开放8001端口firewall-cmd --zone=public --add-port=8001/tcp --permanent 重启防火墙systemctl restart firewalld 访问http://ip:8001/和http://ip:8001/nginx_images/songhuiqiao.jpeg，则分别访问的是/data/nginx_www/index.html静态文件和/data/nginx_images/songhuiqiao.jpeg静态文件 配置为代理服务器 Nginx收到请求后，将请求转发给被代理的服务器，获取到响应之后返给客户端。 创建目录/data/nginx_proxied，并添加index.html文件 cd /etc/nginx/conf.d并修改配置文件static_content.conf为 1234567891011121314151617 server &#123; listen 8001; server_name static_content; root /usr/share/nginx/html; location / &#123; root /data/nginx_www; &#125; location /nginx_images/ &#123; root /data; &#125; location /nginx_proxied/ &#123; proxy_pass http://localhost:8002; &#125;&#125; 即对uri前缀为/nginx_proxied/的请求做代理，被代理地址为http://localhost:8002 配置被代理服务cd /etc/nginx/conf.d并创建配置文件proxied_server.conf： 1234567891011server &#123; listen 8002; root /data/nginx_proxied; location / &#123; &#125; location /nginx_proxied/ &#123; root /data; &#125;&#125; 重新加载nginx配置文件nginx -s reload 访问http:ip:8001/nginx_proxied/ 参考文章 how-to-install-nginx-on-centos-7 Pre-canned Configurations Nginx Beginners’ Guide Nginx server_name 参数配置]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github搭建自己的博客（三）]]></title>
    <url>%2F2018%2F02%2F24%2FHexo-Github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本地搭建好hexo系统后，我们可以将其部署到GitHub上，使用Github Pages访问我们的博客。 部署到GitHub 创建repository在GitHub中New一个repository，注意仓库的名称需要跟我们的GitHub用户名一致（GitHub Pages要求） 为仓库增加deploy key，否则发布过程会出现发布失败 生成本地ssh key，方法 拷贝.ssh/id_rsa.pub文件内的所有内容，进入repository，点击settings，点击Deploy keys，将拷贝的内容Add deploy key 修改站点配置文件1234deploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: master repo也可以配置为https的形式，但是我在发布过程中总是提示我版本不对，因此改用ssh发布 安装发布插件 1npm install hexo-deployer-git --save 发布 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 测试访问https://yourname.github.io/ 定制域名如果我们想自己申请域名作为自己的博客地址，可以使用GitHub Pages的Custom domain功能。 申请域名我是在腾讯云上申请的，然后需要配置我们域名的解析注意记录类型选择CNAME，记录值填写仓库名称即可，表明是域名绑定域名 配置GitHub Pages进入repository的Settings，找到GitHub Pages，并配置custom domain点击Save后，在Code中会增加CNAME文件，内容即为我们的自定义域名。 hexo中增加CNAME文件由于每次Deploy后CNAME文件都会被删掉，因此需要在站点目录下的source中新增CNAME文件，内容为自定义域名 测试访问自定义域名]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github搭建自己的博客（二）]]></title>
    <url>%2F2018%2F02%2F23%2FHexo-Github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Hexo支持各种主题风格，默认使用Landscape主题，本章我们介绍如何使用Next主题美化我们的博客 在Hexo中有两份主要的配置文件，其名称都是_config.yml。 其中，一份位于站点根目录下，主要包含Hexo本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。为了描述方便，在以下说明中，将前者称为站点配置文件， 后者称为主题配置文件。 更换theme 下载Next主题Hexo官网可以下载各种主题，从中找到Next主题的地址，直接下载zip 配置主题将下载的zip文件解压至Hexo/blog/themes下，重命名为hexo-theme-next。 使用主题打开站点配置文件，修改theme配置 1theme: hexo-theme-next 验证主题Git Bash命令界面下，执行如下命令： 12hexo cleanhexo server -p 4001 浏览器中访问http://localhost:4001出现如下界面则更换主题成功 主题设定Next主题主要通过修改主题配置文件和站点配置文件设定自己的博客。 选择scheme修改主题配置文件，检索Scheme Settings1scheme: Pisces 设置博客language修改站点配置文件，检索language1language: zh-CN 设置博客菜单项修改主题配置文件，检索Menu Settings12345menu: home: / || home categories: /categories/ || th tags: /tags/ || tags archives: /archives/ || archive 菜单内容的设置格式是：item name: link || icon name，我只保留了主页，分类，标签，归档。搜索菜单会通过集成第三方服务实现。需要注意的是，添加categories和tags页面之前，这两个按钮都是无效的，后续会有介绍。 设置侧栏修改主题配置文件，检索position1234567sidebar: position: left display: post offset: 12 b2t: false scrollpercent: false onmobile: false 我配置的居左显示，在文章页面（拥有目录列表）时显示 设置头像将头像放置主题目录下的source/uploads/ （目录若不存在则新建uploads）修改主题配置文件，搜索Sidebar Avatar1avatar: /uploads/pic.jpg 主题配置NexT坚持将复杂的细节隐藏，提供尽量少并且简便的设置，保持最大限度的易用性。 设置RSS 安装hexo-generator-feedGit Bash下： 1npm install hexo-generator-feed --save 修改主题配置文件，检索rss 123456789rss:feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: &apos; &apos; 添加标签页面只有添加了标签页面，侧栏中我们配置的「标签」菜单才能点击并响应 站点目录下（即blog目录），Git Bash中 1hexo new page tags 则会在source/tags中新建index.md 设置页面类型 修改步骤1创建中的index.md 1234title: 标签date: 2018-02-22 22:18:27type: &quot;tags&quot;comments: false 其中comments: false是去掉标签页面的评论服务（如果集成了评论服务） 文章中的头部添加tags 12345title: Hexo+Github搭建自己的博客（二）date: 2018-02-23 18:26:04tags: - Hexo - Next 添加分类页面类似于添加标签页面 站点目录下（即blog目录），Git Bash中 1hexo new page categories 则会在source/categories中新建index.md 设置页面类型 修改步骤1创建中的index.md 1234title: 分类date: 2018-02-22 22:37:03type: &quot;categories&quot;comments: false 其中comments: false是去掉分类页面的评论服务（如果集成了评论服务） 文章中的头部添加categories 123456title: Hexo+Github搭建自己的博客（二）date: 2018-02-23 18:26:04tags: - Hexo - Nextcategories: 工具 设置字体包括：全局字体，标题字体，文章字体，Logo字体和代码字体修改主题配置文件，检索Font Settings1234567891011121314151617181920212223242526272829303132333435font: enable: true # 外链字体库地址，例如 //fonts.googleapis.com (默认值) # 预览：https://fonts.google.com/ host: # 全局字体，应用在 body 元素上 global: external: true family: Lato size: 14 # 标题字体 (h1, h2, h3, h4, h5, h6) headings: external: true family: Roboto Slab # 文章字体 posts: external: true family: Microsoft YaHei size: 14 # Logo 字体 logo: external: true family: Lobster Two size: 24 # 代码字体，应用于 code 以及代码块 codes: external: true family: Monospaced size: 13 这是我的字体配置，更多字体 侧边栏设置社交链接修改主题配置文件，检索social123social: GitHub: https://github.com/yourname || github E-Mail: mailto:youremail || envelope 开启打赏功能修改主题配置文件，检索reward_comment123reward_comment: 多谢支持，共同进步！wechatpay: /uploads/微信打赏.jpgalipay: /uploads/支付宝打赏.jpg 添加友情链接修改主题配置文件，检索links_title12345678links_icon: linklinks_title: 友情链接links_layout: inlinelinks: 酷壳: https://coolshell.cn/ SegmentFault: https://segmentfault.com/ DigitalOcean: https://www.digitalocean.com/community 伯乐在线: http://python.jobbole.com/ 设置「阅读全文」首页显示一篇文章的部分内容，并提供一个链接跳转到全文页面。有三种方法： 在文章中使用 &lt;!-- more --&gt;手动进行截断 在文章的 front-matter 中添加 description，并提供文章摘录 自动形成摘要在出题配置文件中，检索auto_excerpt123auto_excerpt: enable: true length: 150 文章中插入图片且可放大查看 修改主题配置文件，检索post_asset_folder，将其置为true 安装hexo-asset-image插件：npm install hexo-asset-image --save。此后使用命令hexo new &quot;博客名称&quot;则会在source/_post文件夹里面就会出现一个“博客名称.md”的文件和一个“博客名称”的文件夹。 安装fancybox插件，并修改主题配置文件，检索fancybox并将其置为true。 文中插入图片：在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，![你想输入的替代文字](xxxx/图片名.jpg) 第三方服务集成评论系统基于来必力的免费city版本搭建。 首先登录来必力官网，在管理页面获取来必力的City版，获取安装代码，从自己的安装代码中获得data-uid，如图： 修改主题配置文件，检索livere_uid1livere_uid: your_uid 另外还可以基于Gitment搭建评论系统，不过我在搭建过程中初始化评论页面的时候遇到“Error: Validation Failed”，没解决因此放弃了。。 百度统计 注册登录百度统计 添加网站：将自己的博客地址添加到自有网站中，点击左侧栏“代码获取”，获取下图中标识的统计id 修改主题配置文件，检索baidu_analytics1baidu_analytics: your_baidu_id 阅读次数统计（后面有更简单方式） 注册登录LeanCloud，创建应用，点击应用，创建Class，Class名称为Counter，选择无限制 设置中，点击“应用Key”，获取AppId，AppKey 修改主题配置文件，检索leancloud_visitors1234leancloud_visitors: enable: true app_id: your_app_id app_key: your_app_key 搜索服务 安装检索插件，站点根目录下Git Bash执行命令 1npm install hexo-generator-searchdb --save 修改站点配置文件添加如下配置 12345search: path: search.xml field: post format: html limit: 10000 修改主题配置文件，启用本地搜索 12local_search: enable: true 其他个性化配置修改文章底部带#的标签修改模板/themes/hexo-theme-next/layout/_macro/post.swig，搜索rel=&quot;tag&quot;&gt;#，将 #换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 在每篇文章末尾统一添加“本文结束”标记 /themes/hexo-theme-next/layout/_macro/目录下新建page-end-tag.swig文件，内容： 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 编辑/themes/hexo-theme-next/layout/_macro/post.swig文件，搜索END POST BODY，在其后面添加如下内容： 12345&#123;% if theme.page_end_tag.enabled and not is_index %&#125; &lt;div&gt; &#123;% include &apos;page-end-tag.swig&apos; %&#125; &lt;/div&gt;&#123;% endif %&#125; 编辑主题配置文件，添加内容： 12page_end_tag: enabled: true 网站底部添加访问量和博客阅读次数统计编辑主题配置文件，检索busuanzi_count12345678busuanzi_count: enable: true total_visitors: true total_visitors_icon: user total_views: true total_views_icon: eye post_views: true post_views_icon: eye 在文章底部增加版权信息方法一修改主题配置文件，检索post_copyright123post_copyright: enable: true license: &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0/&quot; rel=&quot;external nofollow&quot; target=&quot;_blank&quot;&gt;CC BY-NC-SA 4.0&lt;/a&gt; 方法二——自定义 /themes/hexo-theme-next/layout/_macro/目录下新建my-copyright.swig文件，内容： 123456789101112131415161718192021222324252627282930&#123;% if page.copyright %&#125;&lt;div class=&quot;my_post_copyright&quot;&gt; &lt;script src=&quot;//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js&quot;&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/sweetalert/dist/sweetalert.min.js&quot;&gt;&lt;/script&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot;&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href=&quot;/&quot; title=&quot;访问 &#123;&#123; theme.author &#125;&#125; 的个人博客&quot;&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class=&quot;copy-path&quot; title=&quot;点击复制文章链接&quot;&gt;&lt;i class=&quot;fa fa-clipboard&quot; data-clipboard-text=&quot;&#123;&#123; page.permalink &#125;&#125;&quot; aria-label=&quot;复制成功！&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class=&quot;fa fa-creative-commons&quot;&gt;&lt;/i&gt; &lt;a rel=&quot;license&quot; href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; title=&quot;Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)&quot;&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard(&apos;.fa-clipboard&apos;); $(&quot;.fa-clipboard&quot;).click(function()&#123; clipboard.on(&apos;success&apos;, function()&#123; swal(&#123; title: &quot;&quot;, text: &apos;复制成功&apos;, icon: &quot;success&quot;, showConfirmButton: true &#125;); &#125;); &#125;); &lt;/script&gt;&#123;% endif %&#125; 在目录/themes/hexo-theme-next/source/css/_common/components/post/下添加my-post-copyright.styl，内容为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 编辑/themes/hexo-theme-next/layout/_macro/post.swig文件，搜索END POST BODY，在其后面（如果已经添加了文章结束标志则在其后）添加如下内容： 12345&#123;% if not is_index %&#125; &lt;div&gt; &#123;% include &apos;my-copyright.swig&apos; %&#125; &lt;/div&gt;&#123;% endif %&#125; 编辑/themes/hexo-theme-next/source/css/_common/components/post/post.styl文件，在最后一行添加代码： 1@import &quot;my-post-copyright&quot; 修改站点配置文件 1url: http://wfwblog.cn 在文章头部添加copyright 1234567title: Hexo+Github搭建自己的博客（二）date: 2018-02-23 18:26:04tags: - Hexo - Nextcategories: 工具copyright: true 参考文章Next主题使用介绍Next主题个性化配置教程hexo生成博文插入图片]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github搭建自己的博客（一）]]></title>
    <url>%2F2018%2F02%2F23%2FHexo-Github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在查阅资料时，我发现有些人的博客风格简洁而清晰，很喜欢，因此学习基于Hexo+GitHub搭建了一套自己的博客系统，记录如下 环境准备主要完成以下工作： 安装Git 安装node.js 安装Hexo 安装Git 下载Git我使用的v1.9.5，网上说高版本会有问题，未验证 安装注意在步骤2中，选择配置Git环境变量的选项，即：Use Git from the Windows Command Prompt 验证在cmd下，执行命令git --version 安装node.js 下载node.js我使用的v6.3.1 安装 验证在cmd下，执行命令node -v 安装Hexo使用npm命令安装 新建Hexo文件夹，进入Hexo，任意位置点击鼠标右键，选择Git Bash（已经安装Git），步骤2和步骤3命令均在Git bash中执行 使用淘宝npm镜像：npm install -g cnpm --registry=https://registry.npm.taobao.org（需要等待一段时间） 安装hexo：cnpm install -g hexo-cli 验证：cmd下，执行命令hexo -v 运行HexoGit Bash命令界面中，执行命令1234hexo init blogcd blogcnpm installhexo server -p 4001 注意：hexo默认使用4000端口，但是如果4000端口被占用，则会一直没有响应，因此在启动的时候我指定hexo使用4001端口 浏览器中输入http://localhost:4001看到如下页面表明你已经成功了]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
